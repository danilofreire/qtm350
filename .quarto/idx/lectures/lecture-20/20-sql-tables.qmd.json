{"title":"QTM 350 - Data Science Computing","markdown":{"yaml":{"title":"QTM 350 - Data Science Computing","subtitle":"Lecture 19 - Tables and Dates in SQL","author":[{"name":"Danilo Freire","email":"danilo.freire@emory.edu","affiliations":"Emory University"}],"format":{"clean-revealjs":{"self-contained":true,"code-overflow":"wrap","footer":"[SQL Joins](https://raw.githack.com/danilofreire/qtm350/main/lectures/lecture-19/10-sql-tables.html)"}},"transition":"slide","transition-speed":"default","scrollable":true,"engine":"jupyter","revealjs-plugins":["fontawesome","multimodal"],"editor":{"render-on-save":true}},"headingText":"Hello, my friends! 😊 <br>","headingAttr":{"id":"","classes":[],"keyvalue":[["background-color","#2d4563"]]},"containsRefs":false,"markdown":"\n\n\n# Brief recap 📚 {background-color=\"#2d4563\"}\n\n## Recap of last class and today's plan\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n### Last time we learned how to:\n\n- Connect SQL with Python with `psychopg2` and `sqlalchemy`\n- Use many SQL commands, such as `CASE WHEN`, window functions, and string functions\n- Use `pandas` to write SQL queries\n- Fill missing data with `COALESCE`\n- Pivot tables in PostgreSQL\n:::\n\n:::{.column width=\"50%\"}\n### Today we will learn how to:\n\n- See different types of join in SQL\n- Use special joins, such as `CROSS JOIN` and `SELF JOIN`\n- Merge tables by row with `UNION`, `INTERSECT`, and `EXCEPT`\n- Use join conditions with `ON`, `USING`, and `NATURAL JOIN`\n- Solve exercises to practice what we learned\n- Let's get started! 🚀\n\n:::{style=\"text-align: center;\"}\n![](figures/maxresdefault.jpg){width=\"60%\"}\n:::\n:::\n:::\n:::\n\n## An announcement 📢\n\n:::{style=\"margin-top: 50px; font-size: 22px; text-align: center;\"}\n![](figures/alumni.png){width=\"50%\"}\n:::\n\n## Another announcement 📢\n### Final project instructions\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- The instructions for the final project is now available on GitHub\n- Please find it here: <https://github.com/danilofreire/qtm350/blob/main/project/project-instructions.pdf>\n- The project is due on **December 9th, 2024**\n- Groups of 3-4 students\n- You will create a GitHub repository with a report based on World Bank data\n- The report should be in Quarto, the data cleaning and descriptive statistics in SQL, and the data analysis and visualisation in Python\n- QTM 531 students will also have to create a website with the report, as well as to write additional sections in the report\n- Please let me know if you have any questions\n:::\n\n# Basic joins 📊 {background-color=\"#2d4563\"}\n\n## Primary and foreign keys\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- As with many languages, you can merge two tables in SQL either [by columns or by rows]{.alert}\n- Each uses different methods, but the most common is the `JOIN` clause\n- The `JOIN` clause is used to [combine rows and columns from two or more tables]{.alert} based on a related column between them\n- There are two types of keys, [primary and foreign keys]{.alert}\n- The [primary key]{.alert} is a column that [uniquely identifies each row in a table]{.alert}\n  - It must contain a unique value for each row of the table and cannot contain `NULL` values. One table can have only one primary key\n- A [foreign key]{.alert} is a column that [identifies a column in another table]{.alert}\n  - It references the key of another table. One table can have multiple foreign keys, and they can be `NULL`\n\n:::{style=\"text-align: center;\"}\n![](figures/common_database_keys_explained-f_mobile.png){width=\"50%\"}\n:::\n:::\n\n## Load the libraries and connect to the database {#sec:tables}\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Let's load the libraries and connect to the database\n\n```{python}\n#| echo: true\n#| eval: true\nimport pandas as pd\nimport psycopg2\nfrom sqlalchemy import create_engine, text\n\n# Connect to the database\nengine = create_engine('postgresql+psycopg2://postgres:postgres@localhost:5432/postgres')\nconnection = engine.connect()\n```\n\n- Then let's create two tables that we will use to test the `JOIN` clauses\n\n```{python}\n#| echo: true\n#| eval: true\n# Create the tables\nconnection.execute(text('''\nDROP TABLE IF EXISTS players;\nCREATE TABLE players (\n    player_id SERIAL PRIMARY KEY,\n    player_name VARCHAR(50) NOT NULL,\n    goals INT NOT NULL,\n    victories INT NOT NULL\n);\n'''))\n\nconnection.execute(text('''\nDROP TABLE IF EXISTS teams;\nCREATE TABLE teams (\n    team_id SERIAL PRIMARY KEY,\n    team_name VARCHAR(50) NOT NULL\n);\n'''))\nconnection.commit()\n```\n:::\n\n## Create the tables\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Now let's insert some data into the tables\n- Problems with the code below? [Try to clean the database first (see how in this appendix)](#sec:appendix05), then create the connection and tables again\n\n```{python}\n#| echo: true\n#| eval: true\n# Insert data into the tables\nconnection.execute(text('''\nINSERT INTO players (player_name, goals, victories) VALUES\n('Messi', 10, 5),\n('Vini Jr', 8, 4),\n('Neymar', 6, 3),\n('Mbappe', 5, 2),\n('Lewandowski', 4, 1),\n('Haaland', 5, 3);\n'''))\n\nconnection.execute(text('''\nINSERT INTO teams (team_name) VALUES\n('Inter Miami'),\n('Real Madrid'),\n('Al Hilal'),\n('Real Madrid'),\n('Bayern');\n'''))\nconnection.commit()\n```\n:::\n\n## Visualise the tables\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Let's see our tables\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('SELECT * FROM players', connection)\n```\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('SELECT * FROM teams', connection)\n```\n::: \n\n## Types of joins\n\n:::{style=\"margin-top: 50px; font-size: 20px; text-align: center;\"}\n![](figures/joins.webp){width=\"80%\"}\n:::\n\n## Inner join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- The `INNER JOIN` returns only the records where there is a match between both tables (intersection)\n- If there's no match for a record in either table, that record will be excluded from the results\n- Each match creates a new row in the result set that combines columns from both tables\n- The matching condition is specified in the `ON` clause (e.g., `ON table1.id = table2.id`)\n- It is commonly used to combine related data, like the ones we have in the `players` and `teams` tables\n- The syntax is as follows:\n- `SELECT columns FROM table1 INNER JOIN table2 ON table1.column = table2.column`\n- Note that Haaland is not in the `teams` table, so he will not appear in the result set\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name, players.goals, players.victories\nFROM players\nINNER JOIN teams \nON players.player_id = teams.team_id;\n''', connection)\n```\n:::\n\n## Left join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- The `LEFT JOIN` returns all records from the left table (first table) and the matched records from the right table (second table)\n- The result is `NULL` from the right side if there is no match\n- This is perhaps the most common type of join, as it keeps the data from the table we are usually interested in\n- The syntax is as follows (pretty much the same as `INNER JOIN`): \n- `SELECT columns FROM table1 LEFT JOIN table2 ON table1.column = table2.column`\n- Note that Haaland is here because he is in the `players` table, even though he is not in the `teams` table \n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name, players.goals\nFROM players\nLEFT JOIN teams\nON players.player_id = teams.team_id;\n''', connection)\n``` \n:::\n\n## Right join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- The `RIGHT JOIN` returns all records from the right table (second table) and the matched records from the left table (first table)\n- The result is `NULL` from the left side if there is no match\n- As you have probably guessed, this is the opposite of the `LEFT JOIN` (and less common)\n- The syntax is as follows (you have probably guessed it by now 😄):\n- `SELECT columns FROM table1 RIGHT JOIN table2 ON table1.column = table2.column`\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name, players.goals\nFROM players\nRIGHT JOIN teams\nON players.player_id = teams.team_id;\n''', connection)\n```\n:::\n\n## Full outer join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- The `FULL OUTER JOIN` returns all records when there is a match in either left (first) or right (second) table\n- It returns `NULL` values when there is no match\n- In my experience, this is the least common type of join\n- Why? Because it returns all the data from both tables, which can be a lot and not very useful\n- It also overloads the database, as it has to compare all the records from both tables\n  \n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name, players.goals\nFROM players\nFULL OUTER JOIN teams\nON players.player_id = teams.team_id;\n''', connection)\n```\n:::\n\n## Try it yourself! 🧠 {#sec:exercise01a}\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Let's create two new tables and insert some data into them\n\n```{python}\n#| echo: true\n#| eval: true\n# Create the tables and insert data\nconnection.execute(text('''\nDROP TABLE IF EXISTS products CASCADE;\nCREATE TABLE products (\n    product_id SERIAL PRIMARY KEY,\n    product_name VARCHAR(100) NOT NULL,\n    price DECIMAL(10,2) -- 10 digits, 2 decimal places for money\n);\n\n-- Insert products (notice some won't have reviews)\nINSERT INTO products (product_name, price) VALUES\n    ('Coffee Maker', 99.99),\n    ('Toaster', 29.99),\n    ('Blender', 79.99),\n    ('Microwave', 149.99),\n    ('Air Fryer', 89.99);\n\nDROP TABLE IF EXISTS reviews CASCADE;\nCREATE TABLE reviews (\n    review_id SERIAL PRIMARY KEY,\n    product_id INT,\n    rating INT CHECK (rating BETWEEN 1 AND 5),\n    comment TEXT,\n    FOREIGN KEY (product_id) REFERENCES products(product_id)\n);\n\n-- Insert reviews (only for some products)\nINSERT INTO reviews (product_id, rating, comment) VALUES\n    (1, 5, 'Great coffee maker!'),\n    (1, 4, 'Good but expensive'),\n    (2, 3, 'Average toaster'),\n    (3, 5, 'Best blender ever');\n'''))\nconnection.commit()\n```\n:::\n\n## Try it yourself! 🧠 {#sec:exercise01b}\n\n:::{style=\"margin-top: 50px; font-size: 28px;\"}\n- Now try to merge the `directors` and `movies` tables using `INNER JOIN` and `LEFT JOIN`\n- Explain the differences between the two results\n- [[Appendix 01]{.button}](#sec:appendix01)\n:::\n\n# Special joins 🌟 {background-color=\"#2d4563\"}\n\n## Cross join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- `CROSS JOIN` is also available in SQL\n- A cross join does not use any comparisons to determine whether the rows in each table match one another \n- Instead, results are constructed by simply adding each of the rows from the first table to each of the rows of the second table.\n- Useful for generating all possible combinations (e.g., creating a multiplication table)\n- Can be resource-intensive with large tables since result grows exponentially\n- Sometimes written as simple comma-separated tables in `FROM` clause: `SELECT * FROM table1, table2`\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name\nFROM players\nCROSS JOIN teams\nORDER BY players.player_id;\n''', connection)\n```\n::: \n\n## Cross join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- Sometimes it is useful to generate all possible combinations of two tables\n\n```{python}\n#| echo: true\n#| eval: true\n# Drop and recreate tables\nconnection.execute(text('''\nDROP TABLE IF EXISTS colors CASCADE;\nCREATE TABLE colors (color_name VARCHAR(20));\nDROP TABLE IF EXISTS sizes CASCADE;\nCREATE TABLE sizes (size_code VARCHAR(5));\nINSERT INTO colors VALUES ('Black'), ('Red');\nINSERT INTO sizes VALUES ('S'), ('M');\n'''))\n\npd.read_sql(text('''\nSELECT \n    colors.color_name, \n    sizes.size_code,\n    CONCAT(colors.color_name, ' - ', sizes.size_code) as t_shirt\nFROM colors\nCROSS JOIN sizes\nORDER BY colors.color_name, sizes.size_code DESC;\n'''), connection)\n```\n:::\n\n## Self join\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- A self join is a regular join, but [the table is joined with itself]{.alert} (!) 🤯\n- It may not be immediately apparent how this could be useful, but it actually has many applications\n- Often, tables describe entities that can fulfill multiple roles in relationship to one another\n- For instance, if you have a table of `people`, each row could contain a `mother` column that reference other people in the table with the same `person_id`\n- A self join would allow you to stitch these different rows together by joining a second instance of the table to the first where these values match\n\n- Since self joins reference the same table twice, [table aliases are required]{.alert} to disambiguate the references \n- You could join the two instances of the `people` table using the aliases `people AS children` and `people AS mothers`\n- That way, you can specify which instance of the table you are referring to when defining join conditions\n- The syntax is as follows: `SELECT columns FROM table1 AS alias1 JOIN table1 AS alias2 ON alias1.column = alias2.column`\n:::\n\n## Self join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- Let see an example\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nDROP TABLE IF EXISTS family CASCADE;\nCREATE TABLE family (\n    person_id SERIAL PRIMARY KEY,\n    name VARCHAR(50),\n    mother_id INT\n);\n\nINSERT INTO family (name, mother_id) VALUES\n    ('Emma', NULL), -- grandmother\n    ('Sarah', 1),   -- Emma's daughter\n    ('Lisa', 1),    -- Emma's daughter\n    ('Tom', 2),     -- Sarah's son\n    ('Alice', 2);   -- Sarah's daughter\n'''))\n\npd.read_sql('''\nSELECT \n    children.name as child,\n    mothers.name as mother\nFROM family children\nJOIN family mothers ON children.mother_id = mothers.person_id\nORDER BY mothers.name;\n''', connection)\n```\n:::\n\n## Self join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- Let see another example\n- Here we want to calculate the difference in goals between players in the `players` table\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT \n    p1.player_name,\n    p1.goals,\n    p2.player_name as compared_to,\n    p2.goals as their_goals,\n    p1.goals - p2.goals as difference\nFROM players p1\nJOIN players p2 \nON p1.player_id < p2.player_id\nORDER BY difference DESC;\n''', connection)\n```\n::: \n\n## Try it yourself! 🧠 {#sec:exercise02}\n\n:::{style=\"margin-top: 50px; font-size: 24px;\"}\n- Write a SQL query that:\n  - Uses a self join on the players table to compare players' `victories`\n- Shows for each pair of players:\n  - First player's name and victories\n  - Second player's name and victories\n  - The ratio of their victories (rounded to 2 decimal places)\n- Requirements:\n - Use `CAST AS NUMERIC` to handle decimal division (`ROUND(CAST(p1.victories AS NUMERIC) / CAST(p2.victories AS NUMERIC), 2) as victories_ratio`)\n- Avoid duplicate comparisons using `player_id < player_id`\n- Prevent division by zero by adding `WHERE p2.victories > 0`\n- Order results by first player's ID\n- [[Appendix 02]{.button}](#sec:appendix02)\n:::\n\n# Join conditions 🧩 {background-color=\"#2d4563\"}\n\n## Join conditions\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- The most standard way of defining the conditions for table joins is with the `ON` clause\n- `ON` uses an equals sign to specify the exact columns from each table that will be compared \n- PostgreSQL uses the provided columns to stitch together the rows from each table\n- `ON` is verbose, but also very flexible, as it allows you to specify any condition you want\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name, players.goals\nFROM players\nJOIN teams\nON players.player_id = teams.team_id;\n''', connection)\n``` \n:::\n\n:::{.column width=\"50%\"}\n- You can also use the `USING` clause to specify the columns that will be used to join the tables\n- `USING` is a bit more concise than `ON`, as it only requires the column names\n- Let's create a new column `player_id` in the `teams` table to demonstrate how `USING` works\n\n```{python}\n#| echo: true\n#| eval: true\n# First add team_id to players if not exists\nconnection.execute(text('''\nALTER TABLE teams ADD COLUMN IF NOT EXISTS player_id SERIAL;\n'''))\n\n# Show joined data using USING clause\npd.read_sql('''\nSELECT player_name, team_name, goals\nFROM players\nJOIN teams USING (player_id);\n''', connection)\n```\n::: \n:::\n:::\n\n## Natural join\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- This is a cool feature of PostgreSQL!\n- A `NATURAL JOIN` does not specify [any columns]{.alert} to be matched\n- Instead, PostgreSQL will automatically join the tables based on all columns that have matching columns in each database\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name, players.goals\nFROM players\nNATURAL JOIN teams;\n''', connection)\n```\n::: \n\n# Merge tables by row 🧩 {background-color=\"#2d4563\"}\n\n## Union\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- The `UNION` operator is used to combine the result sets of two or more `SELECT` statements\n- It removes duplicate rows between the various `SELECT` statements\n- The columns in each `SELECT` statement must be in the same order, with the same data types\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT player_name, goals FROM players\nUNION\nSELECT team_name, NULL FROM teams\nORDER BY player_name;\n''', connection)\n```\n::: \n\n## Union all and intersect\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- Similar to `UNION`, `UNION ALL` also merges tables by rows\n- Unlike `UNION`, `UNION ALL` retains the duplicate records of both the tables\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nINSERT INTO players (player_name, goals, victories) VALUES ('Real Madrid', 0, 0); \nSELECT player_name FROM players\nUNION ALL\nSELECT team_name FROM teams;\n''', connection)\n```\n:::\n\n:::{.column width=\"50%\"}\n- The `INTERSECT` operator is used to return the common rows between two queries\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nINSERT INTO players (player_name, goals, victories) VALUES ('Real Madrid', 0, 0); \nSELECT player_name FROM players\nINTERSECT\nSELECT team_name FROM teams;\n''', connection)\n```\n:::\n:::\n:::\n\n## Except\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- `EXCEPT` returns the records from the first table (left table) which are not present in the second table (right table)\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nINSERT INTO players (player_name, goals, victories) VALUES ('Real Madrid', 0, 0); \nSELECT player_name FROM players\nEXCEPT\nSELECT team_name FROM teams;\n''', connection)\n```\n:::\n\n# Merge operator {background-color=\"#2d4563\"}\n\n## Merge \n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- PostgreSQL 15 introduced the `MERGE` operator, which allows you to perform an `INSERT`, `UPDATE`, or `DELETE` operation in a single statement\n- It is extremely flexible, easy to read, and efficient. More info [here](https://www.postgresql.org/docs/current/sql-merge.html)\n- It is better to see it with an example\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nALTER TABLE teams ADD COLUMN IF NOT EXISTS player_id SERIAL;\nALTER TABLE teams ADD COLUMN IF NOT EXISTS team_player VARCHAR(100);\n\nMERGE INTO teams AS t\nUSING players AS p\nON t.player_id = p.player_id\nWHEN MATCHED THEN\n    UPDATE SET team_player = (p.player_name || ' - ' || t.team_name)\nWHEN NOT MATCHED THEN\n    INSERT (team_name) VALUES (p.player_name);\n'''))\n\npd.read_sql('SELECT * FROM teams', connection)\n```\n:::\n\n# Conclusion 📖 {background-color=\"#2d4563\"}\n\n## Conclusion\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Today we learned about different types of joins in SQL\n- We also learned about special joins, such as `CROSS JOIN` and `SELF JOIN`\n- We saw how to merge tables by row with `UNION`, `INTERSECT`, and `EXCEPT`\n- We also learned about join conditions with `ON`, `USING`, and `NATURAL JOIN`\n- And we saw the new `MERGE` operator in PostgreSQL 15+ 🚀\n:::\n\n# And that's all for today! 🎉 {background-color=\"#2d4563\"}\n\n# Thank you and have a great rest of your day! 🙏 {background-color=\"#2d4563\"}\n\n## Appendix 01 {#sec:appendix01}\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Here is the solution to the exercise\n  \n```{python}\n#| echo: true\n#| eval: true\nprint(\"INNER JOIN Results:\")\nprint(pd.read_sql('''\n    SELECT p.product_name, r.rating, r.comment\n    FROM products p\n    INNER JOIN reviews r ON p.product_id = r.product_id\n    ORDER BY p.product_id;\n''', connection))\n```\n\n```{python}\n#| echo: true\n#| eval: true\nprint(\"\\nLEFT JOIN Results:\")\nprint(pd.read_sql('''\n    SELECT p.product_name, r.rating, r.comment\n    FROM products p\n    LEFT JOIN reviews r ON p.product_id = r.product_id\n    ORDER BY p.product_id;\n''', connection))\n```\n\n[[Back to exercise]{.button}](#sec:exercise01b)\n:::\n\n## Appendix 02 {#sec:appendix02}\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT p1.player_name, p1.victories, p2.player_name, p2.victories,\n    ROUND(CAST(p1.victories AS NUMERIC) / CAST(p2.victories AS NUMERIC), 2) AS victories_ratio\nFROM players p1\nJOIN players p2\nON p1.player_id < p2.player_id\nWHERE p2.victories > 0\nORDER BY p1.player_id;\n''', connection)\n```\n[[Back to exercise]{.button}](#sec:exercise02)\n::: \n\n\n## Appendix 05 {#sec:appendix05}\n### Cleaning all tables\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- I have encountered some issues with `psycopg2` when trying to drop tables\n- So I created a function to clean all tables in the database\n- If you have a similar issue, you can use the function below\n- Replace the default values with your database name, user, and password\n\n```{python}\n#| echo: true\n#| eval: false\nfrom sqlalchemy import create_engine, text, inspect\nimport time\n\nengine = create_engine('postgresql+psycopg2://postgres:postgres@localhost:5432/postgres', future=True)\nconnection = engine.connect()\n\ndef clean_database(engine):\n    with engine.connect() as conn:\n        try:\n            # Get inspector to check existing tables\n            inspector = inspect(engine)\n            existing_tables = inspector.get_table_names()\n            \n            if not existing_tables:\n                print(\"No tables found in database\")\n                return\n                \n            print(f\"Found {len(existing_tables)} tables: {existing_tables}\")\n            \n            # Kill other connections\n            conn.execute(text(\"\"\"\n                SELECT pg_terminate_backend(pid) \n                FROM pg_stat_activity \n                WHERE pid <> pg_backend_pid()\n                AND datname = current_database()\n            \"\"\"))\n            \n            conn.execute(text(\"ROLLBACK\"))\n            conn.execute(text(\"SET statement_timeout = '30s'\"))\n            \n            # Only drop tables that exist\n            for table in existing_tables:\n                try:\n                    conn.execute(text(f\"DROP TABLE IF EXISTS {table} CASCADE\"))\n                    print(f\"Dropped {table}\")\n                    conn.commit()\n                    time.sleep(1)\n                except Exception as e:\n                    print(f\"Error with {table}: {str(e)}\")\n                    conn.execute(text(\"ROLLBACK\"))\n                    \n        except Exception as e:\n            print(f\"Fatal error: {str(e)}\")\n            conn.execute(text(\"ROLLBACK\"))\n\n# Execute\nclean_database(engine)\n```\n\n[[Back to the lecture]{.button}](#sec:tables)\n:::\n","srcMarkdownNoYaml":"\n\n# Hello, my friends! 😊 <br> {background-color=\"#2d4563\"}\n\n# Brief recap 📚 {background-color=\"#2d4563\"}\n\n## Recap of last class and today's plan\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n### Last time we learned how to:\n\n- Connect SQL with Python with `psychopg2` and `sqlalchemy`\n- Use many SQL commands, such as `CASE WHEN`, window functions, and string functions\n- Use `pandas` to write SQL queries\n- Fill missing data with `COALESCE`\n- Pivot tables in PostgreSQL\n:::\n\n:::{.column width=\"50%\"}\n### Today we will learn how to:\n\n- See different types of join in SQL\n- Use special joins, such as `CROSS JOIN` and `SELF JOIN`\n- Merge tables by row with `UNION`, `INTERSECT`, and `EXCEPT`\n- Use join conditions with `ON`, `USING`, and `NATURAL JOIN`\n- Solve exercises to practice what we learned\n- Let's get started! 🚀\n\n:::{style=\"text-align: center;\"}\n![](figures/maxresdefault.jpg){width=\"60%\"}\n:::\n:::\n:::\n:::\n\n## An announcement 📢\n\n:::{style=\"margin-top: 50px; font-size: 22px; text-align: center;\"}\n![](figures/alumni.png){width=\"50%\"}\n:::\n\n## Another announcement 📢\n### Final project instructions\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- The instructions for the final project is now available on GitHub\n- Please find it here: <https://github.com/danilofreire/qtm350/blob/main/project/project-instructions.pdf>\n- The project is due on **December 9th, 2024**\n- Groups of 3-4 students\n- You will create a GitHub repository with a report based on World Bank data\n- The report should be in Quarto, the data cleaning and descriptive statistics in SQL, and the data analysis and visualisation in Python\n- QTM 531 students will also have to create a website with the report, as well as to write additional sections in the report\n- Please let me know if you have any questions\n:::\n\n# Basic joins 📊 {background-color=\"#2d4563\"}\n\n## Primary and foreign keys\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- As with many languages, you can merge two tables in SQL either [by columns or by rows]{.alert}\n- Each uses different methods, but the most common is the `JOIN` clause\n- The `JOIN` clause is used to [combine rows and columns from two or more tables]{.alert} based on a related column between them\n- There are two types of keys, [primary and foreign keys]{.alert}\n- The [primary key]{.alert} is a column that [uniquely identifies each row in a table]{.alert}\n  - It must contain a unique value for each row of the table and cannot contain `NULL` values. One table can have only one primary key\n- A [foreign key]{.alert} is a column that [identifies a column in another table]{.alert}\n  - It references the key of another table. One table can have multiple foreign keys, and they can be `NULL`\n\n:::{style=\"text-align: center;\"}\n![](figures/common_database_keys_explained-f_mobile.png){width=\"50%\"}\n:::\n:::\n\n## Load the libraries and connect to the database {#sec:tables}\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Let's load the libraries and connect to the database\n\n```{python}\n#| echo: true\n#| eval: true\nimport pandas as pd\nimport psycopg2\nfrom sqlalchemy import create_engine, text\n\n# Connect to the database\nengine = create_engine('postgresql+psycopg2://postgres:postgres@localhost:5432/postgres')\nconnection = engine.connect()\n```\n\n- Then let's create two tables that we will use to test the `JOIN` clauses\n\n```{python}\n#| echo: true\n#| eval: true\n# Create the tables\nconnection.execute(text('''\nDROP TABLE IF EXISTS players;\nCREATE TABLE players (\n    player_id SERIAL PRIMARY KEY,\n    player_name VARCHAR(50) NOT NULL,\n    goals INT NOT NULL,\n    victories INT NOT NULL\n);\n'''))\n\nconnection.execute(text('''\nDROP TABLE IF EXISTS teams;\nCREATE TABLE teams (\n    team_id SERIAL PRIMARY KEY,\n    team_name VARCHAR(50) NOT NULL\n);\n'''))\nconnection.commit()\n```\n:::\n\n## Create the tables\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Now let's insert some data into the tables\n- Problems with the code below? [Try to clean the database first (see how in this appendix)](#sec:appendix05), then create the connection and tables again\n\n```{python}\n#| echo: true\n#| eval: true\n# Insert data into the tables\nconnection.execute(text('''\nINSERT INTO players (player_name, goals, victories) VALUES\n('Messi', 10, 5),\n('Vini Jr', 8, 4),\n('Neymar', 6, 3),\n('Mbappe', 5, 2),\n('Lewandowski', 4, 1),\n('Haaland', 5, 3);\n'''))\n\nconnection.execute(text('''\nINSERT INTO teams (team_name) VALUES\n('Inter Miami'),\n('Real Madrid'),\n('Al Hilal'),\n('Real Madrid'),\n('Bayern');\n'''))\nconnection.commit()\n```\n:::\n\n## Visualise the tables\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Let's see our tables\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('SELECT * FROM players', connection)\n```\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('SELECT * FROM teams', connection)\n```\n::: \n\n## Types of joins\n\n:::{style=\"margin-top: 50px; font-size: 20px; text-align: center;\"}\n![](figures/joins.webp){width=\"80%\"}\n:::\n\n## Inner join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- The `INNER JOIN` returns only the records where there is a match between both tables (intersection)\n- If there's no match for a record in either table, that record will be excluded from the results\n- Each match creates a new row in the result set that combines columns from both tables\n- The matching condition is specified in the `ON` clause (e.g., `ON table1.id = table2.id`)\n- It is commonly used to combine related data, like the ones we have in the `players` and `teams` tables\n- The syntax is as follows:\n- `SELECT columns FROM table1 INNER JOIN table2 ON table1.column = table2.column`\n- Note that Haaland is not in the `teams` table, so he will not appear in the result set\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name, players.goals, players.victories\nFROM players\nINNER JOIN teams \nON players.player_id = teams.team_id;\n''', connection)\n```\n:::\n\n## Left join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- The `LEFT JOIN` returns all records from the left table (first table) and the matched records from the right table (second table)\n- The result is `NULL` from the right side if there is no match\n- This is perhaps the most common type of join, as it keeps the data from the table we are usually interested in\n- The syntax is as follows (pretty much the same as `INNER JOIN`): \n- `SELECT columns FROM table1 LEFT JOIN table2 ON table1.column = table2.column`\n- Note that Haaland is here because he is in the `players` table, even though he is not in the `teams` table \n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name, players.goals\nFROM players\nLEFT JOIN teams\nON players.player_id = teams.team_id;\n''', connection)\n``` \n:::\n\n## Right join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- The `RIGHT JOIN` returns all records from the right table (second table) and the matched records from the left table (first table)\n- The result is `NULL` from the left side if there is no match\n- As you have probably guessed, this is the opposite of the `LEFT JOIN` (and less common)\n- The syntax is as follows (you have probably guessed it by now 😄):\n- `SELECT columns FROM table1 RIGHT JOIN table2 ON table1.column = table2.column`\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name, players.goals\nFROM players\nRIGHT JOIN teams\nON players.player_id = teams.team_id;\n''', connection)\n```\n:::\n\n## Full outer join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- The `FULL OUTER JOIN` returns all records when there is a match in either left (first) or right (second) table\n- It returns `NULL` values when there is no match\n- In my experience, this is the least common type of join\n- Why? Because it returns all the data from both tables, which can be a lot and not very useful\n- It also overloads the database, as it has to compare all the records from both tables\n  \n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name, players.goals\nFROM players\nFULL OUTER JOIN teams\nON players.player_id = teams.team_id;\n''', connection)\n```\n:::\n\n## Try it yourself! 🧠 {#sec:exercise01a}\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Let's create two new tables and insert some data into them\n\n```{python}\n#| echo: true\n#| eval: true\n# Create the tables and insert data\nconnection.execute(text('''\nDROP TABLE IF EXISTS products CASCADE;\nCREATE TABLE products (\n    product_id SERIAL PRIMARY KEY,\n    product_name VARCHAR(100) NOT NULL,\n    price DECIMAL(10,2) -- 10 digits, 2 decimal places for money\n);\n\n-- Insert products (notice some won't have reviews)\nINSERT INTO products (product_name, price) VALUES\n    ('Coffee Maker', 99.99),\n    ('Toaster', 29.99),\n    ('Blender', 79.99),\n    ('Microwave', 149.99),\n    ('Air Fryer', 89.99);\n\nDROP TABLE IF EXISTS reviews CASCADE;\nCREATE TABLE reviews (\n    review_id SERIAL PRIMARY KEY,\n    product_id INT,\n    rating INT CHECK (rating BETWEEN 1 AND 5),\n    comment TEXT,\n    FOREIGN KEY (product_id) REFERENCES products(product_id)\n);\n\n-- Insert reviews (only for some products)\nINSERT INTO reviews (product_id, rating, comment) VALUES\n    (1, 5, 'Great coffee maker!'),\n    (1, 4, 'Good but expensive'),\n    (2, 3, 'Average toaster'),\n    (3, 5, 'Best blender ever');\n'''))\nconnection.commit()\n```\n:::\n\n## Try it yourself! 🧠 {#sec:exercise01b}\n\n:::{style=\"margin-top: 50px; font-size: 28px;\"}\n- Now try to merge the `directors` and `movies` tables using `INNER JOIN` and `LEFT JOIN`\n- Explain the differences between the two results\n- [[Appendix 01]{.button}](#sec:appendix01)\n:::\n\n# Special joins 🌟 {background-color=\"#2d4563\"}\n\n## Cross join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- `CROSS JOIN` is also available in SQL\n- A cross join does not use any comparisons to determine whether the rows in each table match one another \n- Instead, results are constructed by simply adding each of the rows from the first table to each of the rows of the second table.\n- Useful for generating all possible combinations (e.g., creating a multiplication table)\n- Can be resource-intensive with large tables since result grows exponentially\n- Sometimes written as simple comma-separated tables in `FROM` clause: `SELECT * FROM table1, table2`\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name\nFROM players\nCROSS JOIN teams\nORDER BY players.player_id;\n''', connection)\n```\n::: \n\n## Cross join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- Sometimes it is useful to generate all possible combinations of two tables\n\n```{python}\n#| echo: true\n#| eval: true\n# Drop and recreate tables\nconnection.execute(text('''\nDROP TABLE IF EXISTS colors CASCADE;\nCREATE TABLE colors (color_name VARCHAR(20));\nDROP TABLE IF EXISTS sizes CASCADE;\nCREATE TABLE sizes (size_code VARCHAR(5));\nINSERT INTO colors VALUES ('Black'), ('Red');\nINSERT INTO sizes VALUES ('S'), ('M');\n'''))\n\npd.read_sql(text('''\nSELECT \n    colors.color_name, \n    sizes.size_code,\n    CONCAT(colors.color_name, ' - ', sizes.size_code) as t_shirt\nFROM colors\nCROSS JOIN sizes\nORDER BY colors.color_name, sizes.size_code DESC;\n'''), connection)\n```\n:::\n\n## Self join\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- A self join is a regular join, but [the table is joined with itself]{.alert} (!) 🤯\n- It may not be immediately apparent how this could be useful, but it actually has many applications\n- Often, tables describe entities that can fulfill multiple roles in relationship to one another\n- For instance, if you have a table of `people`, each row could contain a `mother` column that reference other people in the table with the same `person_id`\n- A self join would allow you to stitch these different rows together by joining a second instance of the table to the first where these values match\n\n- Since self joins reference the same table twice, [table aliases are required]{.alert} to disambiguate the references \n- You could join the two instances of the `people` table using the aliases `people AS children` and `people AS mothers`\n- That way, you can specify which instance of the table you are referring to when defining join conditions\n- The syntax is as follows: `SELECT columns FROM table1 AS alias1 JOIN table1 AS alias2 ON alias1.column = alias2.column`\n:::\n\n## Self join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- Let see an example\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nDROP TABLE IF EXISTS family CASCADE;\nCREATE TABLE family (\n    person_id SERIAL PRIMARY KEY,\n    name VARCHAR(50),\n    mother_id INT\n);\n\nINSERT INTO family (name, mother_id) VALUES\n    ('Emma', NULL), -- grandmother\n    ('Sarah', 1),   -- Emma's daughter\n    ('Lisa', 1),    -- Emma's daughter\n    ('Tom', 2),     -- Sarah's son\n    ('Alice', 2);   -- Sarah's daughter\n'''))\n\npd.read_sql('''\nSELECT \n    children.name as child,\n    mothers.name as mother\nFROM family children\nJOIN family mothers ON children.mother_id = mothers.person_id\nORDER BY mothers.name;\n''', connection)\n```\n:::\n\n## Self join\n\n:::{style=\"margin-top: 50px; font-size: 18px;\"}\n- Let see another example\n- Here we want to calculate the difference in goals between players in the `players` table\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT \n    p1.player_name,\n    p1.goals,\n    p2.player_name as compared_to,\n    p2.goals as their_goals,\n    p1.goals - p2.goals as difference\nFROM players p1\nJOIN players p2 \nON p1.player_id < p2.player_id\nORDER BY difference DESC;\n''', connection)\n```\n::: \n\n## Try it yourself! 🧠 {#sec:exercise02}\n\n:::{style=\"margin-top: 50px; font-size: 24px;\"}\n- Write a SQL query that:\n  - Uses a self join on the players table to compare players' `victories`\n- Shows for each pair of players:\n  - First player's name and victories\n  - Second player's name and victories\n  - The ratio of their victories (rounded to 2 decimal places)\n- Requirements:\n - Use `CAST AS NUMERIC` to handle decimal division (`ROUND(CAST(p1.victories AS NUMERIC) / CAST(p2.victories AS NUMERIC), 2) as victories_ratio`)\n- Avoid duplicate comparisons using `player_id < player_id`\n- Prevent division by zero by adding `WHERE p2.victories > 0`\n- Order results by first player's ID\n- [[Appendix 02]{.button}](#sec:appendix02)\n:::\n\n# Join conditions 🧩 {background-color=\"#2d4563\"}\n\n## Join conditions\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- The most standard way of defining the conditions for table joins is with the `ON` clause\n- `ON` uses an equals sign to specify the exact columns from each table that will be compared \n- PostgreSQL uses the provided columns to stitch together the rows from each table\n- `ON` is verbose, but also very flexible, as it allows you to specify any condition you want\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name, players.goals\nFROM players\nJOIN teams\nON players.player_id = teams.team_id;\n''', connection)\n``` \n:::\n\n:::{.column width=\"50%\"}\n- You can also use the `USING` clause to specify the columns that will be used to join the tables\n- `USING` is a bit more concise than `ON`, as it only requires the column names\n- Let's create a new column `player_id` in the `teams` table to demonstrate how `USING` works\n\n```{python}\n#| echo: true\n#| eval: true\n# First add team_id to players if not exists\nconnection.execute(text('''\nALTER TABLE teams ADD COLUMN IF NOT EXISTS player_id SERIAL;\n'''))\n\n# Show joined data using USING clause\npd.read_sql('''\nSELECT player_name, team_name, goals\nFROM players\nJOIN teams USING (player_id);\n''', connection)\n```\n::: \n:::\n:::\n\n## Natural join\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- This is a cool feature of PostgreSQL!\n- A `NATURAL JOIN` does not specify [any columns]{.alert} to be matched\n- Instead, PostgreSQL will automatically join the tables based on all columns that have matching columns in each database\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT players.player_name, teams.team_name, players.goals\nFROM players\nNATURAL JOIN teams;\n''', connection)\n```\n::: \n\n# Merge tables by row 🧩 {background-color=\"#2d4563\"}\n\n## Union\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- The `UNION` operator is used to combine the result sets of two or more `SELECT` statements\n- It removes duplicate rows between the various `SELECT` statements\n- The columns in each `SELECT` statement must be in the same order, with the same data types\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT player_name, goals FROM players\nUNION\nSELECT team_name, NULL FROM teams\nORDER BY player_name;\n''', connection)\n```\n::: \n\n## Union all and intersect\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- Similar to `UNION`, `UNION ALL` also merges tables by rows\n- Unlike `UNION`, `UNION ALL` retains the duplicate records of both the tables\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nINSERT INTO players (player_name, goals, victories) VALUES ('Real Madrid', 0, 0); \nSELECT player_name FROM players\nUNION ALL\nSELECT team_name FROM teams;\n''', connection)\n```\n:::\n\n:::{.column width=\"50%\"}\n- The `INTERSECT` operator is used to return the common rows between two queries\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nINSERT INTO players (player_name, goals, victories) VALUES ('Real Madrid', 0, 0); \nSELECT player_name FROM players\nINTERSECT\nSELECT team_name FROM teams;\n''', connection)\n```\n:::\n:::\n:::\n\n## Except\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- `EXCEPT` returns the records from the first table (left table) which are not present in the second table (right table)\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nINSERT INTO players (player_name, goals, victories) VALUES ('Real Madrid', 0, 0); \nSELECT player_name FROM players\nEXCEPT\nSELECT team_name FROM teams;\n''', connection)\n```\n:::\n\n# Merge operator {background-color=\"#2d4563\"}\n\n## Merge \n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- PostgreSQL 15 introduced the `MERGE` operator, which allows you to perform an `INSERT`, `UPDATE`, or `DELETE` operation in a single statement\n- It is extremely flexible, easy to read, and efficient. More info [here](https://www.postgresql.org/docs/current/sql-merge.html)\n- It is better to see it with an example\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nALTER TABLE teams ADD COLUMN IF NOT EXISTS player_id SERIAL;\nALTER TABLE teams ADD COLUMN IF NOT EXISTS team_player VARCHAR(100);\n\nMERGE INTO teams AS t\nUSING players AS p\nON t.player_id = p.player_id\nWHEN MATCHED THEN\n    UPDATE SET team_player = (p.player_name || ' - ' || t.team_name)\nWHEN NOT MATCHED THEN\n    INSERT (team_name) VALUES (p.player_name);\n'''))\n\npd.read_sql('SELECT * FROM teams', connection)\n```\n:::\n\n# Conclusion 📖 {background-color=\"#2d4563\"}\n\n## Conclusion\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Today we learned about different types of joins in SQL\n- We also learned about special joins, such as `CROSS JOIN` and `SELF JOIN`\n- We saw how to merge tables by row with `UNION`, `INTERSECT`, and `EXCEPT`\n- We also learned about join conditions with `ON`, `USING`, and `NATURAL JOIN`\n- And we saw the new `MERGE` operator in PostgreSQL 15+ 🚀\n:::\n\n# And that's all for today! 🎉 {background-color=\"#2d4563\"}\n\n# Thank you and have a great rest of your day! 🙏 {background-color=\"#2d4563\"}\n\n## Appendix 01 {#sec:appendix01}\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Here is the solution to the exercise\n  \n```{python}\n#| echo: true\n#| eval: true\nprint(\"INNER JOIN Results:\")\nprint(pd.read_sql('''\n    SELECT p.product_name, r.rating, r.comment\n    FROM products p\n    INNER JOIN reviews r ON p.product_id = r.product_id\n    ORDER BY p.product_id;\n''', connection))\n```\n\n```{python}\n#| echo: true\n#| eval: true\nprint(\"\\nLEFT JOIN Results:\")\nprint(pd.read_sql('''\n    SELECT p.product_name, r.rating, r.comment\n    FROM products p\n    LEFT JOIN reviews r ON p.product_id = r.product_id\n    ORDER BY p.product_id;\n''', connection))\n```\n\n[[Back to exercise]{.button}](#sec:exercise01b)\n:::\n\n## Appendix 02 {#sec:appendix02}\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql('''\nSELECT p1.player_name, p1.victories, p2.player_name, p2.victories,\n    ROUND(CAST(p1.victories AS NUMERIC) / CAST(p2.victories AS NUMERIC), 2) AS victories_ratio\nFROM players p1\nJOIN players p2\nON p1.player_id < p2.player_id\nWHERE p2.victories > 0\nORDER BY p1.player_id;\n''', connection)\n```\n[[Back to exercise]{.button}](#sec:exercise02)\n::: \n\n\n## Appendix 05 {#sec:appendix05}\n### Cleaning all tables\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- I have encountered some issues with `psycopg2` when trying to drop tables\n- So I created a function to clean all tables in the database\n- If you have a similar issue, you can use the function below\n- Replace the default values with your database name, user, and password\n\n```{python}\n#| echo: true\n#| eval: false\nfrom sqlalchemy import create_engine, text, inspect\nimport time\n\nengine = create_engine('postgresql+psycopg2://postgres:postgres@localhost:5432/postgres', future=True)\nconnection = engine.connect()\n\ndef clean_database(engine):\n    with engine.connect() as conn:\n        try:\n            # Get inspector to check existing tables\n            inspector = inspect(engine)\n            existing_tables = inspector.get_table_names()\n            \n            if not existing_tables:\n                print(\"No tables found in database\")\n                return\n                \n            print(f\"Found {len(existing_tables)} tables: {existing_tables}\")\n            \n            # Kill other connections\n            conn.execute(text(\"\"\"\n                SELECT pg_terminate_backend(pid) \n                FROM pg_stat_activity \n                WHERE pid <> pg_backend_pid()\n                AND datname = current_database()\n            \"\"\"))\n            \n            conn.execute(text(\"ROLLBACK\"))\n            conn.execute(text(\"SET statement_timeout = '30s'\"))\n            \n            # Only drop tables that exist\n            for table in existing_tables:\n                try:\n                    conn.execute(text(f\"DROP TABLE IF EXISTS {table} CASCADE\"))\n                    print(f\"Dropped {table}\")\n                    conn.commit()\n                    time.sleep(1)\n                except Exception as e:\n                    print(f\"Error with {table}: {str(e)}\")\n                    conn.execute(text(\"ROLLBACK\"))\n                    \n        except Exception as e:\n            print(f\"Fatal error: {str(e)}\")\n            conn.execute(text(\"ROLLBACK\"))\n\n# Execute\nclean_database(engine)\n```\n\n[[Back to the lecture]{.button}](#sec:tables)\n:::\n"},"formats":{"clean-revealjs":{"identifier":{"display-name":"RevealJS","target-format":"clean-revealjs","base-format":"revealjs","extension-name":"clean"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"shortcodes":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","filters":[],"self-contained":true,"output-file":"20-sql-tables.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.42","auto-stretch":true,"theme":["default","_extensions/grantmcdermott/clean/clean.scss"],"menu":{"side":"left"},"slideNumber":true,"date-format":"long","revealjs-plugins":["fontawesome","multimodal"],"title":"QTM 350 - Data Science Computing","subtitle":"Lecture 19 - Tables and Dates in SQL","author":[{"name":"Danilo Freire","email":"danilo.freire@emory.edu","affiliations":"Emory University"}],"transition":"slide","transitionSpeed":"default","scrollable":true,"editor":{"render-on-save":true},"footer":"[SQL Joins](https://raw.githack.com/danilofreire/qtm350/main/lectures/lecture-19/10-sql-tables.html)"}}},"projectFormats":["html"]}