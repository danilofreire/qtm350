{"title":"QTM 350 - Data Science Computing","markdown":{"yaml":{"title":"QTM 350 - Data Science Computing","subtitle":"Lecture 19 - SQL and Python","author":[{"name":"Danilo Freire","email":"danilo.freire@emory.edu","affiliations":"Emory University"}],"format":{"clean-revealjs":{"self-contained":true,"code-overflow":"wrap","footer":"[SQL and Python](https://raw.githack.com/danilofreire/qtm350/main/lectures/lecture-19/19-sql-python.html)"}},"transition":"slide","transition-speed":"default","scrollable":true,"engine":"jupyter","revealjs-plugins":["fontawesome","multimodal"],"editor":{"render-on-save":true}},"headingText":"Hello! Great to see you again! üòä","headingAttr":{"id":"","classes":[],"keyvalue":[["background-color","#2d4563"]]},"containsRefs":false,"markdown":"\n\n\n# Lecture overview üìö {background-color=\"#2d4563\"}\n\n## Lecture overview\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n### Last time we learned:\n\n- What are relational databases and why they are still dominant in data science\n- How to install and run SQLite\n- How to create databases, tables, and insert data\n- How to perform queries with `SELECT`, `WHERE` and `ORDER BY`\n- Group data with `GROUP BY` and filter groups with `HAVING`\n- Compute statistics with `COUNT`, `SUM`, `AVG`, `MIN`, and `MAX`\n- That's quite a lot! ü§ì\n- [By the way, any issues with the installation?]{.alert} ü§î\n:::\n\n:::{.column width=\"50%\"}\n### Today we will learn:\n\n- How to connect SQL with Python, because we all love Python! üêç üòÇ\n- We will use the `sqlite3` libraries (and `pandas` too! üêº)\n- We will also learn about other SQL commands, such as `LIKE`, `IN`, `BETWEEN`, `CASE`, window functions, and string functions like `LEFT`, `RIGHT`, and `LENGTH`\n- How to fill missing data with `COALESCE`\n- Let's get started! üöÄ\n:::\n:::\n:::\n\n# Connecting SQL with Python üêç {background-color=\"#2d4563\"}\n\n## Why connect SQL with Python?\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- SQL is great for data manipulation and querying, but it is not a programming language\n- So it is useful to connect SQL with a programming language that allows for more complex operations, data visualisation, and machine learning\n- Do you know any programming language that does that? _Of course you do!_ \n- So let's see how to connect SQL with Python! üêç\n- First, let's install the `psycopg2` and `sqlalchemy` libraries\n\n```{verbatim}\npip install psycopg2 sqlalchemy\n\n# or\n# conda install psycopg2 sqlalchemy\n```\n:::\n\n:::{.column width=\"50%\"}\n:::{style=\"text-align: center;\"}\n[![](figures/sqlalchemy.jpg){width=\"60%\"}](https://www.sqlalchemy.org/){data-modal-type=\"iframe\"}\n:::\n\n- `psycopg2` is a PostgreSQL adapter for Python (more info [here](https://www.psycopg.org/docs/){data-modal-type=\"iframe\"})\n- It allows you to connect to a PostgreSQL database and execute SQL commands\n- `sqlalchemy` is a SQL for Python, and it is database-agnostic\n-  More information about it [here](https://www.sqlalchemy.org/){data-modal-type=\"iframe\"}\n- Both of them are very popular and work well together (and with other Python libraries too)\n:::\n:::\n:::\n\n## Connecting to a PostgreSQL database\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- `sqlalchemy` generates SQL statements and `psycopg2` sends SQL statements to the database\n- So let's load the libraries! ü§ì\n\n```{python}\n#| echo: true\n#| eval: true\nimport psycopg2\nfrom sqlalchemy import create_engine, text\n```\n\n- Now let's connect to the database\n- We need the database name, user, password, and host\n\n```{python}\n#| echo: true\n#| eval: true\n# Connection parameters\nengine = create_engine('postgresql+psycopg2://postgres:postgres@localhost:5432/postgres')\nconnection = engine.connect()\n```\n\n- Let's see what every part of the connection string means\n- `create_engine()` creates a connection to the database\n- `postgresql+psycopg2` is the database driver\n- `postgres:postgres` is the username and password\n- `localhost:5432` is the host and port\n- `postgres` is the database name\n:::\n\n# SQL commands in Python üêç {background-color=\"#2d4563\"}\n\n## Executing SQL commands in Python {#sec:tables}\n\n:::{style=\"margin-top: 50px; font-size: 19px;\"}\n:::{.columns}\n:::{.column width=\"40%\"}\n- Now that we have connected to the database, we can execute SQL commands\n- We can use the `execute()` method of the connection object\n- Let's see an example\n\n```{python}\n#| echo: true\n#| eval: true\n# Create drivers table\nconnection.execute(text('''\nDROP TABLE IF EXISTS drivers;\nCREATE TABLE drivers (\n    driver_id SERIAL PRIMARY KEY,\n    driver_name VARCHAR(50),\n    team VARCHAR(50),\n    nationality VARCHAR(50),\n    victories INT\n);\n'''))\nconnection.commit()\n```\n\n- The `commit()` method is necessary to save the changes, otherwise they will be lost\n- Problems with the code below? [Try to clean the database first (see how in this appendix)](#sec:appendix05), then create the connection and tables again\n:::\n\n:::{.column width=\"60%\"}\n- The `execute()` method receives a string with the SQL command\n- We can use triple quotes to write multi-line strings\n- Let's add some data to the table\n\n```{python}\n#| echo: true\n#| eval: true\n# Add data to the drivers table\nconnection.execute(text('''\nINSERT INTO drivers (driver_name, team, nationality, victories)\nVALUES \n    ('Lewis Hamilton', 'Mercedes', 'British', 103),\n    ('Max Verstappen', 'Red Bull Racing', 'Dutch', 55),\n    ('Charles Leclerc', 'Ferrari', 'Mon√©gasque', 5),\n    ('Fernando Alonso', 'Aston Martin', NULL, NULL)\n'''))\nconnection.commit()\n```\n\n- Now let's check if the data were inserted correctly\n- We can use the `SELECT` command for that, and `fetchall()` to retrieve the data\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('SELECT * FROM drivers')).fetchall()\n```\n:::\n:::\n:::\n\n## `IN` and `BETWEEN` operators\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- We use `IN` to filter data based on a list of values\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE team IN ('Ferrari', 'Mercedes');\n''')).fetchall()\n```\n\n- `BETWEEN` is used to filter data within a range\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE victories BETWEEN 50 AND 100;\n''')).fetchall()\n```\n\n- We can also use `NOT IN` and `NOT BETWEEN` to exclude values\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE team NOT IN ('Ferrari', 'Mercedes');\n''')).fetchall()\n```\n:::\n\n## `LIKE`, `ILIKE`, and `SIMILAR TO` operators\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- We can use the `LIKE` operator to filter data based on patterns\n- `%` is a wildcard that matches any sequence of characters\n- `_` is a wildcard that matches any single character\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE driver_name LIKE 'L%';\n''')).fetchall()\n```\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE team LIKE 'M______s';\n''')).fetchall()\n```\n\n- We can also use `NOT LIKE` to exclude patterns\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE driver_name NOT LIKE 'L%';\n''')).fetchall()\n```\n:::\n\n:::{.column width=\"50%\"}\n- `ILIKE` is the case-insensitive version of `LIKE`\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE driver_name ILIKE 'l%';\n''')).fetchall()\n```\n\n- `SIMILAR TO` is another operator that allows for more complex patterns\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE driver_name SIMILAR TO 'L[a-z]%';\n''')).fetchall()\n```\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers\nWHERE team SIMILAR TO '%(Racing|Martin)';\n''')).fetchall()\n``` \n\n- More about [regex in PostgreSQL](https://www.postgresql.org/docs/13/functions-matching.html)\n:::\n:::\n:::\n\n## Try it yourself! ü§ì {#sec:exercise01}\n\n:::{style=\"margin-top: 50px; font-size: 24px;\"}\n- Now it's your turn to practice!\n- Find all drivers whose names start with 'M'\n- Find drivers whose nationality contain exactly 7 characters\n- List drivers whose names start with either 'L' or 'M'\n- Find drivers who have won between 1 and 10 races\n- [[Appendix 01]{.button}](#sec:appendix01)\n:::\n\n# Missing data {background-color=\"#2d4563\"}\n\n## `IS NULL` and `COALESCE` operators\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- We can also use `IS NULL` to check for missing values\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE victories IS NULL;\n''')).fetchall()\n```\n\n- We can fill missing values with `COALESCE`\n- It is a simple impuation method that replaces missing values with a constant\n- The syntax is `COALESCE(column_name, value)`\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, COALESCE(victories, 30) FROM drivers;\n''')).fetchall()\n```\n:::\n\n## `COALESCE` with subqueries\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- We can also use `COALESCE` with subqueries\n- Subqueries are used when we need to compute a value based on another query, usually for aggregation purposes\n- In this example, we compute the average number of victories and use it to fill missing values (rounding to 2 decimal places)\n- Note the use of `::int` to convert the result to an integer\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT \n  driver_name,\n  COALESCE(victories, \n    (SELECT AVG(victories)::int\n     FROM drivers \n     WHERE victories IS NOT NULL)) \nFROM drivers;\n''')).fetchall()\n```\n::: \n\n# Window functions {background-color=\"#2d4563\"}\n\n## Window functions\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Window functions are used to compute values based on a group of rows\n- They are similar to aggregation functions, but they [do not reduce the number of rows]{.alert}\n- The syntax is `function() OVER (PARTITION BY column ORDER BY column)`\n- We can use `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`, `LAG()`, `LEAD()`, and many others\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nINSERT INTO drivers (driver_name, team, nationality, victories)\nVALUES \n    ('Valtteri Bottas', 'Mercedes', 'Finnish', 10),\n    ('Sergio Perez', 'Red Bull Racing', 'Mexican', 5),\n    ('Lando Norris', 'McLaren', 'British', 2),\n    ('Esteban Ocon', 'Ferrari', 'French', 1)\n''')) \n\nconnection.execute(text('''\nSELECT driver_name, team, victories,\n    ROUND(AVG(victories) OVER (), 2) AS avg_victories,\n    ROUND(AVG(victories) OVER (PARTITION BY team), 2) AS avg_victories_team,\n    RANK() OVER (ORDER BY victories DESC) AS rank\nFROM drivers\nORDER BY victories DESC;\n''')).fetchall()\n```\n:::\n\n## Window functions versus `GROUP BY`\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n### `GROUP BY`\n\n- `GROUP BY` [reduces the number of rows]{.alert} in the result set\n- It is used to aggregate data based on a column\n- It is useful to compute statistics for groups of data, but it is not as flexible as window functions\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT team, ROUND(AVG(victories), 2) AS avg_victories\nFROM drivers\nGROUP BY team;\n''')).fetchall()\n```\n:::\n\n:::{.column width=\"50%\"}\n### Window functions\n\n- Window functions can have [multiple partitions]{.alert} and [orderings]{.alert}, and they are particularly useful for time series data, when we need to compute values based on a time window\n- For instance, they can be used to calculate moving averages, cumulative sums, and other statistics\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT \n    driver_name, \n    team, \n    victories,\n    ROUND(AVG(victories) OVER (PARTITION BY team), 2) AS avg_victories_team,\n    RANK() OVER (ORDER BY victories DESC) AS rank,\n    RANK() OVER (PARTITION BY team ORDER BY victories DESC) AS rank_team\nFROM drivers\nWHERE victories IS NOT NULL\nORDER BY rank ASC;\n''')).fetchall()\n``` \n:::\n:::\n:::\n\n## Try it yourself! ü§ì {#sec:exercise02}\n\n:::{style=\"margin-top: 50px; font-size: 24px;\"}\n- Select the variables `driver_name`, `nationality`, and `victories` from the `drivers` table\n- Create a column called `rank_nationality` that ranks drivers based on the number of victories and their nationality\n- Drop missing values in the `victories` column\n- Order the results by `rank_nationality`\n- [[Appendix 02]{.button}](#sec:appendix02)\n:::\n\n# String functions {background-color=\"#2d4563\"}\n\n## String functions\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- SQL has several string functions that can be used to manipulate text data\n- We can use `LEFT()`, `RIGHT()`, `LENGTH()`, `UPPER()`, `LOWER()`, `INITCAP()`, `TRIM()`, `REPLACE()`, and many others\n- They are usually very similar to their Python counterparts (and straightforward to use!)\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    LEFT(driver_name, 5) AS first_name,\n    RIGHT(driver_name, 8) AS last_name,\n    LENGTH(driver_name) AS name_length,\n    UPPER(driver_name) AS upper_name,\n    LOWER(driver_name) AS lower_name,\n    INITCAP(driver_name) AS initcap_name\nFROM drivers;\n''')).fetchall()\n```\n:::\n\n## String functions\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- We can also use `TRIM()` to remove leading and trailing spaces\n- `STRPOS()` returns the position of a substring in a string\n- `REPLACE()` is used to replace a substring with another substring\n- `CONCAT()` concatenates strings\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    TRIM(driver_name) AS trimmed_name,\n    STRPOS(driver_name, 'a') AS a_position,\n    REPLACE(driver_name, ' ', '_') AS replaced_name,\n    CONCAT(driver_name, ' is a great driver!') AS message\nFROM drivers;\n''')).fetchall()\n```\n:::\n\n# CASE statement <br> (If-Then-Else) {background-color=\"#2d4563\"}\n\n## `CASE` statement\n\n:::{style=\"margin-top: 50px; font-size: 17px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- SQL does not have an `IF` statement, but we can use the `CASE` statement\n- It works exactly like `if` statements in other programming languages\n- The syntax is `CASE WHEN condition THEN value ELSE value END`\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    CASE \n        WHEN victories > 50 THEN 'Great driver'\n        ELSE 'Good driver'\n    END\nFROM drivers;\n''')).fetchall()\n```\n:::\n\n:::{.column width=\"50%\"}\n- We can also use `CASE` with multiple conditions\n- The `AS` keyword is used to rename the column\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    CASE \n        WHEN victories > 50 THEN 'Great driver'\n        WHEN victories < 10 THEN 'Average driver'\n        ELSE 'No data'\n    END AS driver_status\nFROM drivers;\n''')).fetchall()\n```\n\n- `CASE` can be combined with `IN` and `BETWEEN` operators\n- It is a very versatile statement! ü§ì\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    CASE \n        WHEN victories IN (5, 54) THEN 'Good driver'\n        WHEN victories BETWEEN 55 AND 110 THEN 'Great driver'\n        ELSE 'No data'\n    END AS driver_status\nFROM drivers;\n''')).fetchall()\n```\n:::\n:::\n:::\n\n## `CASE` for missing values\n\n:::{style=\"margin-top: 50px; font-size: 19px;\"}\n- `CASE` can also be useful to fill missing values with conditions\n- Let's add some missing values to the table\n  \n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE victories IS NULL;\n''')).fetchall()\n```\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    CASE \n        WHEN nationality IS NULL THEN 'Spanish'\n        ELSE nationality\n    END,\n    CASE \n        WHEN victories IS NULL THEN 30\n        ELSE victories\n    END\nFROM drivers\n''')).fetchall()\n```\n\n- Note the use of [commas to separate the columns]{.alert}\n:::\n\n## Try it yourself! ü§ì {#sec:exercise03}\n\n:::{style=\"margin-top: 50px; font-size: 24px;\"}\n- Let's see if you can use the `CASE` statement\n- Create a column called `driver_level` that classifies drivers as 'Beginner', 'Intermediate', or 'Expert' based on the number of victories\n  - 'Beginner' if victories < 10\n  - 'Intermediate' if victories between 10 and 100\n  - 'Expert' if victories > 100\n- [[Appendix 03]{.button}](#sec:appendix03) \n:::\n\n# Using SQL with `pandas` üêº {background-color=\"#2d4563\"}\n\n## Using SQL with `pandas`\n\n:::{style=\"margin-top: 50px; font-size: 19px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- We all know that `pandas` is great! üòé\n- And it can be even better when combined with SQL queries\n- We can use the `read_sql()` method to read data from a SQL query\n\n```{python}\n#| echo: true\n#| eval: true\nimport pandas as pd\n\n# Read data from SQL query\ndf = pd.read_sql('SELECT * FROM drivers', connection)\ndf\n```\n:::\n\n:::{.column width=\"50%\"}\n- You can pass any SQL query to the `read_sql()` method\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql(\n  \"SELECT * FROM drivers WHERE victories > 50 AND nationality = 'British'\", \n  connection\n)\n```\n\n<br>\n\n- Yes, it is that simple! ü§ì\n- And you all now want to kill me for not showing this before! üòÇ\n- Just connect to the database using `sqlalchemy` and use `read_sql()` to read the data if that's what you want\n- Note the use of double quotes for the SQL query and single quotes for the strings\n- SQL only accepts single quotes, so be careful with that üòâ\n:::\n:::\n:::\n\n## Using SQL with `pandas`\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- We can then use any `pandas` method to manipulate the data\n\n```{python}\n#| echo: true\n#| eval: true\ndf.groupby('team').agg(avg_victories=('victories', 'mean')).dropna()\n```\n\n- Using `.query()` to filter data\n\n```{python}\n#| echo: true\n#| eval: true\ndf.query('victories > 50')\n```\n:::\n\n:::{.column width=\"50%\"}\n- We can also write data to a SQL table with the `to_sql()` method\n\n```{python}\n#| echo: true\n#| eval: true\ndf.to_sql('drivers_copy', connection, if_exists='replace', index=False)\n\n# Check if the data were written correctly\npd.read_sql('SELECT * FROM drivers_copy', connection)\n```\n:::\n:::\n:::\n\n## Try it yourself! ü§ì {#sec:exercise04}\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Create a new SQL table called `employees` with the following columns:\n  - `employee_id` (serial, primary key)\n  - `employee_name` (varchar(50))\n  - `department` (varchar(50))\n  - `salary` (int)\n- Remember to drop the table if it already exists\n- Insert some data into the table and read it with `pandas` (you can see the example below)\n- Commit the changes\n- Use `pandas` to compute the average salary by department\n\n```{python}\n#| echo: true\n#| eval: false\n# Create employees table first, then insert data\n'Alice', 'HR', 5000\n'Bob', 'IT', 6000\n'Charlie', 'HR', 7000\n'David', 'IT', 8000\n```\n\n- [[Appendix 04]{.button}](#sec:appendix04)\n:::\n\n# Pivot tables in SQL üìÑ {background-color=\"#2d4563\"}\n\n## Pivot tables in SQL\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- We have already seen how to pivot tables in `pandas`\n- But we can also pivot tables in SQL too\n- We can use the `CASE` function to pivot tables, which is similar to the `pivot_table()` method in `pandas`\n- Let's create another table with student scores\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nDROP TABLE IF EXISTS student_scores;\nCREATE TABLE student_scores (\n    student_name VARCHAR(50),\n    subject VARCHAR(50),\n    score INTEGER,\n    term VARCHAR(10)\n);\n\nINSERT INTO student_scores (student_name, subject, score, term)\nVALUES \n    ('Alice', 'Maths', 90, 'Q1'),\n    ('Alice', 'Maths', 80, 'Q2'),\n    ('Alice', 'Science', 80, 'Q1'),\n    ('Alice', 'Science', 75, 'Q2'),\n    ('Bob', 'Maths', 80, 'Q1'),\n    ('Bob', 'Maths', 100, 'Q2'),\n    ('Bob', 'Science', 80, 'Q1'),\n    ('Bob', 'Science', 70, 'Q2'),\n    ('Charles', 'Maths', 70, 'Q1'),\n    ('Charles', 'Maths', 75, 'Q2'),\n    ('Charles', 'Science', 90, 'Q1'),\n    ('Charles', 'Science', 85, 'Q2')\n'''))\n\nconnection.commit()\n\nconnection.execute(text('SELECT * FROM student_scores')).fetchall()\n```\n:::\n\n## Pivot tables in SQL\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Now let's pivot the table using the `CASE` function\n- We will focus on the students' scores in Math and Science\n- Let's calculate their average scores for each subject\n\n```{python}\n#| echo: true\n#| eval: true\ndf2 = pd.read_sql('''\nSELECT \n    student_name,\n    AVG(CASE WHEN subject = 'Maths' THEN score END) as Maths,\n    AVG(CASE WHEN subject = 'Science' THEN score END) as Science,\n    AVG(score) as total\nFROM student_scores\nGROUP BY student_name\nORDER BY total DESC;\n''', connection)\n\ndf2\n```\n:::\n\n## Pivot tables in SQL\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- PostgreSQL also has a `crosstab` function that can be used to pivot tables\n- It is a bit more complex than the `CASE` function, but it works fine\n- The syntax is `crosstab(text, text)` and it requires the `tablefunc` extension\n- We can install the extension with the command below\n\n```{python}\n#| echo: true\n#} eval: true\nconnection.execute(text('CREATE EXTENSION IF NOT EXISTS tablefunc;'))\nconnection.commit()\n\ndf3 = pd.read_sql('''\nDROP TABLE IF EXISTS ct;\nSELECT student_name, Maths, Science, (Maths + Science)/2 as Total\nFROM crosstab(\n    'SELECT student_name, subject, AVG(score)\n     FROM student_scores\n     GROUP BY student_name, subject\n     ORDER BY student_name, subject',\n    'SELECT DISTINCT subject FROM student_scores ORDER BY subject'\n) AS ct (\n    student_name VARCHAR, Maths NUMERIC, Science NUMERIC\n);\n''', connection)\n\ndf3\n```\n:::\n\n## Pivot tables in SQL\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- Let's break the code down \n- We first dropped the table `ct` if it already exists, just to avoid conflicts\n  - `DROP TABLE IF EXISTS ct;`\n- We then used the `crosstab` function to pivot the table\n  - `SELECT student_name, subject, AVG(score) FROM student_scores GROUP BY student_name, subject ORDER BY student_name, subject`\n  - `SELECT DISTINCT subject FROM student_scores ORDER BY subject`\n- We calculated the total score as the average of the scores in Maths and Science\n:::\n\n:::{.column width=\"50%\"}\n- The `crosstab` function requires two arguments\n  - The first argument is the query to retrieve the data\n  - The second argument is the query to retrieve the column names\n- We then used the `AS` keyword to rename the columns and assigned the result to a new table called `ct`\n  - `AS ct (student_name VARCHAR, Maths NUMERIC, Science NUMERIC)`\n- And that's it! ü§ì\n:::\n:::\n:::\n\n# Conclusion üìö {background-color=\"#2d4563\"}\n\n## Conclusion\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- SQL is cool, SQL + Python is even cooler! üòé\n- We can use `psycopg2` and `sqlalchemy` to connect to a PostgreSQL database\n- We can execute SQL commands with `execute()` and `fetchall()`\n- Functions like `IN`, `BETWEEN`, `LIKE`, `CASE`, and window functions are very useful\n- There are also many string functions that can be used to manipulate text data\n- We can fill missing values with `COALESCE` and pivot tables with the `CASE` function or the `crosstab` function\n- And we can use `pandas` to read data from SQL queries and manipulate it\n:::\n\n:::{.column width=\"50%\"}\n:::{style=\"text-align: center;\"}\n[![](figures/pandasql5.jpg){width=\"100%\"}](https://www.sqlalchemy.org/){data-modal-type=\"iframe\"}\n\nSource: [Susan Ibach](https://susanibach.wordpress.com/2020/01/07/pandas-for-sql-lovers-select-from-table/)\n:::\n:::\n:::\n:::\n\n# And that's all for today! üöÄ {background-color=\"#2d4563\"}\n\n# Have a great day! üòä {background-color=\"#2d4563\"}\n\n## Appendix 01 {#sec:appendix01}\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- Find all drivers whose names start with 'M'\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE driver_name LIKE 'M%';\n''')).fetchall()\n```\n\n- Find drivers whose nationality contains exactly 7 characters\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE nationality LIKE '_______';\n''')).fetchall()\n```\n\n- Or we can use the `LENGTH` function\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE LENGTH(nationality) = 7;\n''')).fetchall()\n```\n\n[[Back to exercise]{.button}](#sec:exercise01)\n:::\n\n## Appendix 01\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- List drivers whose names start with either 'L' or 'M'\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE driver_name LIKE 'L%' OR driver_name LIKE 'M%';\n''')).fetchall()\n```\n\n- Find drivers who have won between 10 and 50 races\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE victories BETWEEN 1 AND 10;\n''')).fetchall()\n```\n\n[[Back to exercise]{.button}](#sec:exercise01)\n:::\n\n## Appendix 02 {#sec:appendix02}\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- Create a column called `rank_nationality` that ranks drivers based on the number of victories and their nationality\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, nationality, victories,\n    RANK() OVER (PARTITION BY nationality ORDER BY victories DESC) AS rank_nationality\nFROM drivers\nWHERE victories IS NOT NULL\nORDER BY rank_nationality\n''')).fetchall()\n```\n\n[[Back to exercise]{.button}](#sec:exercise02)\n:::\n\n\n## Appendix 03 {#sec:appendix03}\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- Create a column called `driver_level` that classifies drivers as 'Beginner', 'Intermediate', or 'Expert' based on the number of victories\n  - `Beginner` if victories < 10\n  - `Intermediate` if victories between 10 and 50\n  - `Expert` if victories > 50\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    CASE \n        WHEN victories < 10 THEN 'Beginner'\n        WHEN victories BETWEEN 10 AND 100 THEN 'Intermediate'\n        ELSE 'Expert'\n    END AS driver_level\nFROM drivers;\n''')).fetchall()\n```\n\n[[Back to exercise]{.button}](#sec:exercise02)\n:::\n\n## Appendix 04 {#sec:appendix04}\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- Create a new SQL table called `employees` with the following columns:\n  - `employee_id` (serial, primary key)\n  - `employee_name` (varchar(50))\n  - `department` (varchar(50))\n  - `salary` (int)\n- Commit the changes\n- Insert some data into the table and read it with `pandas` (you can see the example below)\n- Use `pandas` to compute the average salary by department\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nDROP TABLE IF EXISTS employees;\nCREATE TABLE employees (\n    employee_id SERIAL PRIMARY KEY,\n    employee_name VARCHAR(50),\n    department VARCHAR(50),\n    salary INT\n);\n'''))\n\nconnection.execute(text('''\nINSERT INTO employees (employee_name, department, salary)\nVALUES \n    ('Alice', 'HR', 5000),\n    ('Bob', 'IT', 6000),\n    ('Charlie', 'HR', 7000),\n    ('David', 'IT', 8000)\n'''))\n\nconnection.commit()\n\n# Read data with pandas\npd.read_sql('SELECT * FROM employees', connection)\n\n# Compute average salary by department\npd.read_sql('SELECT department, AVG(salary) FROM employees GROUP BY department', connection)\n```\n\n[[Back to exercise]{.button}](#sec:exercise03)\n:::\n\n## Appendix 05 {#sec:appendix05}\n### Cleaning all tables\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- I have encountered some issues with `psycopg2` when trying to drop tables\n- So I created a function to clean all tables in the database\n- If you have a similar issue, you can use the function below\n- Replace the default values with your database name, user, and password\n\n```{python}\n#| echo: true\n#| eval: false\nfrom sqlalchemy import create_engine, text, inspect\nimport time\n\nengine = create_engine('postgresql+psycopg2://postgres:postgres@localhost:5432/postgres', future=True)\nconnection = engine.connect()\n\ndef clean_database(engine):\n    with engine.connect() as conn:\n        try:\n            # Get inspector to check existing tables\n            inspector = inspect(engine)\n            existing_tables = inspector.get_table_names()\n            \n            if not existing_tables:\n                print(\"No tables found in database\")\n                return\n                \n            print(f\"Found {len(existing_tables)} tables: {existing_tables}\")\n            \n            # Kill other connections\n            conn.execute(text(\"\"\"\n                SELECT pg_terminate_backend(pid) \n                FROM pg_stat_activity \n                WHERE pid <> pg_backend_pid()\n                AND datname = current_database()\n            \"\"\"))\n            \n            conn.execute(text(\"ROLLBACK\"))\n            conn.execute(text(\"SET statement_timeout = '30s'\"))\n            \n            # Only drop tables that exist\n            for table in existing_tables:\n                try:\n                    conn.execute(text(f\"DROP TABLE IF EXISTS {table} CASCADE\"))\n                    print(f\"Dropped {table}\")\n                    conn.commit()\n                    time.sleep(1)\n                except Exception as e:\n                    print(f\"Error with {table}: {str(e)}\")\n                    conn.execute(text(\"ROLLBACK\"))\n                    \n        except Exception as e:\n            print(f\"Fatal error: {str(e)}\")\n            conn.execute(text(\"ROLLBACK\"))\n\n# Execute\nclean_database(engine)\n```\n\n[[Back to the lecture]{.button}](#sec:tables)\n:::\n","srcMarkdownNoYaml":"\n\n# Hello! Great to see you again! üòä {background-color=\"#2d4563\"}\n\n# Lecture overview üìö {background-color=\"#2d4563\"}\n\n## Lecture overview\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n### Last time we learned:\n\n- What are relational databases and why they are still dominant in data science\n- How to install and run SQLite\n- How to create databases, tables, and insert data\n- How to perform queries with `SELECT`, `WHERE` and `ORDER BY`\n- Group data with `GROUP BY` and filter groups with `HAVING`\n- Compute statistics with `COUNT`, `SUM`, `AVG`, `MIN`, and `MAX`\n- That's quite a lot! ü§ì\n- [By the way, any issues with the installation?]{.alert} ü§î\n:::\n\n:::{.column width=\"50%\"}\n### Today we will learn:\n\n- How to connect SQL with Python, because we all love Python! üêç üòÇ\n- We will use the `sqlite3` libraries (and `pandas` too! üêº)\n- We will also learn about other SQL commands, such as `LIKE`, `IN`, `BETWEEN`, `CASE`, window functions, and string functions like `LEFT`, `RIGHT`, and `LENGTH`\n- How to fill missing data with `COALESCE`\n- Let's get started! üöÄ\n:::\n:::\n:::\n\n# Connecting SQL with Python üêç {background-color=\"#2d4563\"}\n\n## Why connect SQL with Python?\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- SQL is great for data manipulation and querying, but it is not a programming language\n- So it is useful to connect SQL with a programming language that allows for more complex operations, data visualisation, and machine learning\n- Do you know any programming language that does that? _Of course you do!_ \n- So let's see how to connect SQL with Python! üêç\n- First, let's install the `psycopg2` and `sqlalchemy` libraries\n\n```{verbatim}\npip install psycopg2 sqlalchemy\n\n# or\n# conda install psycopg2 sqlalchemy\n```\n:::\n\n:::{.column width=\"50%\"}\n:::{style=\"text-align: center;\"}\n[![](figures/sqlalchemy.jpg){width=\"60%\"}](https://www.sqlalchemy.org/){data-modal-type=\"iframe\"}\n:::\n\n- `psycopg2` is a PostgreSQL adapter for Python (more info [here](https://www.psycopg.org/docs/){data-modal-type=\"iframe\"})\n- It allows you to connect to a PostgreSQL database and execute SQL commands\n- `sqlalchemy` is a SQL for Python, and it is database-agnostic\n-  More information about it [here](https://www.sqlalchemy.org/){data-modal-type=\"iframe\"}\n- Both of them are very popular and work well together (and with other Python libraries too)\n:::\n:::\n:::\n\n## Connecting to a PostgreSQL database\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- `sqlalchemy` generates SQL statements and `psycopg2` sends SQL statements to the database\n- So let's load the libraries! ü§ì\n\n```{python}\n#| echo: true\n#| eval: true\nimport psycopg2\nfrom sqlalchemy import create_engine, text\n```\n\n- Now let's connect to the database\n- We need the database name, user, password, and host\n\n```{python}\n#| echo: true\n#| eval: true\n# Connection parameters\nengine = create_engine('postgresql+psycopg2://postgres:postgres@localhost:5432/postgres')\nconnection = engine.connect()\n```\n\n- Let's see what every part of the connection string means\n- `create_engine()` creates a connection to the database\n- `postgresql+psycopg2` is the database driver\n- `postgres:postgres` is the username and password\n- `localhost:5432` is the host and port\n- `postgres` is the database name\n:::\n\n# SQL commands in Python üêç {background-color=\"#2d4563\"}\n\n## Executing SQL commands in Python {#sec:tables}\n\n:::{style=\"margin-top: 50px; font-size: 19px;\"}\n:::{.columns}\n:::{.column width=\"40%\"}\n- Now that we have connected to the database, we can execute SQL commands\n- We can use the `execute()` method of the connection object\n- Let's see an example\n\n```{python}\n#| echo: true\n#| eval: true\n# Create drivers table\nconnection.execute(text('''\nDROP TABLE IF EXISTS drivers;\nCREATE TABLE drivers (\n    driver_id SERIAL PRIMARY KEY,\n    driver_name VARCHAR(50),\n    team VARCHAR(50),\n    nationality VARCHAR(50),\n    victories INT\n);\n'''))\nconnection.commit()\n```\n\n- The `commit()` method is necessary to save the changes, otherwise they will be lost\n- Problems with the code below? [Try to clean the database first (see how in this appendix)](#sec:appendix05), then create the connection and tables again\n:::\n\n:::{.column width=\"60%\"}\n- The `execute()` method receives a string with the SQL command\n- We can use triple quotes to write multi-line strings\n- Let's add some data to the table\n\n```{python}\n#| echo: true\n#| eval: true\n# Add data to the drivers table\nconnection.execute(text('''\nINSERT INTO drivers (driver_name, team, nationality, victories)\nVALUES \n    ('Lewis Hamilton', 'Mercedes', 'British', 103),\n    ('Max Verstappen', 'Red Bull Racing', 'Dutch', 55),\n    ('Charles Leclerc', 'Ferrari', 'Mon√©gasque', 5),\n    ('Fernando Alonso', 'Aston Martin', NULL, NULL)\n'''))\nconnection.commit()\n```\n\n- Now let's check if the data were inserted correctly\n- We can use the `SELECT` command for that, and `fetchall()` to retrieve the data\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('SELECT * FROM drivers')).fetchall()\n```\n:::\n:::\n:::\n\n## `IN` and `BETWEEN` operators\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- We use `IN` to filter data based on a list of values\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE team IN ('Ferrari', 'Mercedes');\n''')).fetchall()\n```\n\n- `BETWEEN` is used to filter data within a range\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE victories BETWEEN 50 AND 100;\n''')).fetchall()\n```\n\n- We can also use `NOT IN` and `NOT BETWEEN` to exclude values\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE team NOT IN ('Ferrari', 'Mercedes');\n''')).fetchall()\n```\n:::\n\n## `LIKE`, `ILIKE`, and `SIMILAR TO` operators\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- We can use the `LIKE` operator to filter data based on patterns\n- `%` is a wildcard that matches any sequence of characters\n- `_` is a wildcard that matches any single character\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE driver_name LIKE 'L%';\n''')).fetchall()\n```\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE team LIKE 'M______s';\n''')).fetchall()\n```\n\n- We can also use `NOT LIKE` to exclude patterns\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE driver_name NOT LIKE 'L%';\n''')).fetchall()\n```\n:::\n\n:::{.column width=\"50%\"}\n- `ILIKE` is the case-insensitive version of `LIKE`\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE driver_name ILIKE 'l%';\n''')).fetchall()\n```\n\n- `SIMILAR TO` is another operator that allows for more complex patterns\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE driver_name SIMILAR TO 'L[a-z]%';\n''')).fetchall()\n```\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers\nWHERE team SIMILAR TO '%(Racing|Martin)';\n''')).fetchall()\n``` \n\n- More about [regex in PostgreSQL](https://www.postgresql.org/docs/13/functions-matching.html)\n:::\n:::\n:::\n\n## Try it yourself! ü§ì {#sec:exercise01}\n\n:::{style=\"margin-top: 50px; font-size: 24px;\"}\n- Now it's your turn to practice!\n- Find all drivers whose names start with 'M'\n- Find drivers whose nationality contain exactly 7 characters\n- List drivers whose names start with either 'L' or 'M'\n- Find drivers who have won between 1 and 10 races\n- [[Appendix 01]{.button}](#sec:appendix01)\n:::\n\n# Missing data {background-color=\"#2d4563\"}\n\n## `IS NULL` and `COALESCE` operators\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- We can also use `IS NULL` to check for missing values\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE victories IS NULL;\n''')).fetchall()\n```\n\n- We can fill missing values with `COALESCE`\n- It is a simple impuation method that replaces missing values with a constant\n- The syntax is `COALESCE(column_name, value)`\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, COALESCE(victories, 30) FROM drivers;\n''')).fetchall()\n```\n:::\n\n## `COALESCE` with subqueries\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- We can also use `COALESCE` with subqueries\n- Subqueries are used when we need to compute a value based on another query, usually for aggregation purposes\n- In this example, we compute the average number of victories and use it to fill missing values (rounding to 2 decimal places)\n- Note the use of `::int` to convert the result to an integer\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT \n  driver_name,\n  COALESCE(victories, \n    (SELECT AVG(victories)::int\n     FROM drivers \n     WHERE victories IS NOT NULL)) \nFROM drivers;\n''')).fetchall()\n```\n::: \n\n# Window functions {background-color=\"#2d4563\"}\n\n## Window functions\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Window functions are used to compute values based on a group of rows\n- They are similar to aggregation functions, but they [do not reduce the number of rows]{.alert}\n- The syntax is `function() OVER (PARTITION BY column ORDER BY column)`\n- We can use `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()`, `LAG()`, `LEAD()`, and many others\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nINSERT INTO drivers (driver_name, team, nationality, victories)\nVALUES \n    ('Valtteri Bottas', 'Mercedes', 'Finnish', 10),\n    ('Sergio Perez', 'Red Bull Racing', 'Mexican', 5),\n    ('Lando Norris', 'McLaren', 'British', 2),\n    ('Esteban Ocon', 'Ferrari', 'French', 1)\n''')) \n\nconnection.execute(text('''\nSELECT driver_name, team, victories,\n    ROUND(AVG(victories) OVER (), 2) AS avg_victories,\n    ROUND(AVG(victories) OVER (PARTITION BY team), 2) AS avg_victories_team,\n    RANK() OVER (ORDER BY victories DESC) AS rank\nFROM drivers\nORDER BY victories DESC;\n''')).fetchall()\n```\n:::\n\n## Window functions versus `GROUP BY`\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n### `GROUP BY`\n\n- `GROUP BY` [reduces the number of rows]{.alert} in the result set\n- It is used to aggregate data based on a column\n- It is useful to compute statistics for groups of data, but it is not as flexible as window functions\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT team, ROUND(AVG(victories), 2) AS avg_victories\nFROM drivers\nGROUP BY team;\n''')).fetchall()\n```\n:::\n\n:::{.column width=\"50%\"}\n### Window functions\n\n- Window functions can have [multiple partitions]{.alert} and [orderings]{.alert}, and they are particularly useful for time series data, when we need to compute values based on a time window\n- For instance, they can be used to calculate moving averages, cumulative sums, and other statistics\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT \n    driver_name, \n    team, \n    victories,\n    ROUND(AVG(victories) OVER (PARTITION BY team), 2) AS avg_victories_team,\n    RANK() OVER (ORDER BY victories DESC) AS rank,\n    RANK() OVER (PARTITION BY team ORDER BY victories DESC) AS rank_team\nFROM drivers\nWHERE victories IS NOT NULL\nORDER BY rank ASC;\n''')).fetchall()\n``` \n:::\n:::\n:::\n\n## Try it yourself! ü§ì {#sec:exercise02}\n\n:::{style=\"margin-top: 50px; font-size: 24px;\"}\n- Select the variables `driver_name`, `nationality`, and `victories` from the `drivers` table\n- Create a column called `rank_nationality` that ranks drivers based on the number of victories and their nationality\n- Drop missing values in the `victories` column\n- Order the results by `rank_nationality`\n- [[Appendix 02]{.button}](#sec:appendix02)\n:::\n\n# String functions {background-color=\"#2d4563\"}\n\n## String functions\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- SQL has several string functions that can be used to manipulate text data\n- We can use `LEFT()`, `RIGHT()`, `LENGTH()`, `UPPER()`, `LOWER()`, `INITCAP()`, `TRIM()`, `REPLACE()`, and many others\n- They are usually very similar to their Python counterparts (and straightforward to use!)\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    LEFT(driver_name, 5) AS first_name,\n    RIGHT(driver_name, 8) AS last_name,\n    LENGTH(driver_name) AS name_length,\n    UPPER(driver_name) AS upper_name,\n    LOWER(driver_name) AS lower_name,\n    INITCAP(driver_name) AS initcap_name\nFROM drivers;\n''')).fetchall()\n```\n:::\n\n## String functions\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- We can also use `TRIM()` to remove leading and trailing spaces\n- `STRPOS()` returns the position of a substring in a string\n- `REPLACE()` is used to replace a substring with another substring\n- `CONCAT()` concatenates strings\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    TRIM(driver_name) AS trimmed_name,\n    STRPOS(driver_name, 'a') AS a_position,\n    REPLACE(driver_name, ' ', '_') AS replaced_name,\n    CONCAT(driver_name, ' is a great driver!') AS message\nFROM drivers;\n''')).fetchall()\n```\n:::\n\n# CASE statement <br> (If-Then-Else) {background-color=\"#2d4563\"}\n\n## `CASE` statement\n\n:::{style=\"margin-top: 50px; font-size: 17px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- SQL does not have an `IF` statement, but we can use the `CASE` statement\n- It works exactly like `if` statements in other programming languages\n- The syntax is `CASE WHEN condition THEN value ELSE value END`\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    CASE \n        WHEN victories > 50 THEN 'Great driver'\n        ELSE 'Good driver'\n    END\nFROM drivers;\n''')).fetchall()\n```\n:::\n\n:::{.column width=\"50%\"}\n- We can also use `CASE` with multiple conditions\n- The `AS` keyword is used to rename the column\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    CASE \n        WHEN victories > 50 THEN 'Great driver'\n        WHEN victories < 10 THEN 'Average driver'\n        ELSE 'No data'\n    END AS driver_status\nFROM drivers;\n''')).fetchall()\n```\n\n- `CASE` can be combined with `IN` and `BETWEEN` operators\n- It is a very versatile statement! ü§ì\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    CASE \n        WHEN victories IN (5, 54) THEN 'Good driver'\n        WHEN victories BETWEEN 55 AND 110 THEN 'Great driver'\n        ELSE 'No data'\n    END AS driver_status\nFROM drivers;\n''')).fetchall()\n```\n:::\n:::\n:::\n\n## `CASE` for missing values\n\n:::{style=\"margin-top: 50px; font-size: 19px;\"}\n- `CASE` can also be useful to fill missing values with conditions\n- Let's add some missing values to the table\n  \n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE victories IS NULL;\n''')).fetchall()\n```\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    CASE \n        WHEN nationality IS NULL THEN 'Spanish'\n        ELSE nationality\n    END,\n    CASE \n        WHEN victories IS NULL THEN 30\n        ELSE victories\n    END\nFROM drivers\n''')).fetchall()\n```\n\n- Note the use of [commas to separate the columns]{.alert}\n:::\n\n## Try it yourself! ü§ì {#sec:exercise03}\n\n:::{style=\"margin-top: 50px; font-size: 24px;\"}\n- Let's see if you can use the `CASE` statement\n- Create a column called `driver_level` that classifies drivers as 'Beginner', 'Intermediate', or 'Expert' based on the number of victories\n  - 'Beginner' if victories < 10\n  - 'Intermediate' if victories between 10 and 100\n  - 'Expert' if victories > 100\n- [[Appendix 03]{.button}](#sec:appendix03) \n:::\n\n# Using SQL with `pandas` üêº {background-color=\"#2d4563\"}\n\n## Using SQL with `pandas`\n\n:::{style=\"margin-top: 50px; font-size: 19px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- We all know that `pandas` is great! üòé\n- And it can be even better when combined with SQL queries\n- We can use the `read_sql()` method to read data from a SQL query\n\n```{python}\n#| echo: true\n#| eval: true\nimport pandas as pd\n\n# Read data from SQL query\ndf = pd.read_sql('SELECT * FROM drivers', connection)\ndf\n```\n:::\n\n:::{.column width=\"50%\"}\n- You can pass any SQL query to the `read_sql()` method\n\n```{python}\n#| echo: true\n#| eval: true\npd.read_sql(\n  \"SELECT * FROM drivers WHERE victories > 50 AND nationality = 'British'\", \n  connection\n)\n```\n\n<br>\n\n- Yes, it is that simple! ü§ì\n- And you all now want to kill me for not showing this before! üòÇ\n- Just connect to the database using `sqlalchemy` and use `read_sql()` to read the data if that's what you want\n- Note the use of double quotes for the SQL query and single quotes for the strings\n- SQL only accepts single quotes, so be careful with that üòâ\n:::\n:::\n:::\n\n## Using SQL with `pandas`\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- We can then use any `pandas` method to manipulate the data\n\n```{python}\n#| echo: true\n#| eval: true\ndf.groupby('team').agg(avg_victories=('victories', 'mean')).dropna()\n```\n\n- Using `.query()` to filter data\n\n```{python}\n#| echo: true\n#| eval: true\ndf.query('victories > 50')\n```\n:::\n\n:::{.column width=\"50%\"}\n- We can also write data to a SQL table with the `to_sql()` method\n\n```{python}\n#| echo: true\n#| eval: true\ndf.to_sql('drivers_copy', connection, if_exists='replace', index=False)\n\n# Check if the data were written correctly\npd.read_sql('SELECT * FROM drivers_copy', connection)\n```\n:::\n:::\n:::\n\n## Try it yourself! ü§ì {#sec:exercise04}\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Create a new SQL table called `employees` with the following columns:\n  - `employee_id` (serial, primary key)\n  - `employee_name` (varchar(50))\n  - `department` (varchar(50))\n  - `salary` (int)\n- Remember to drop the table if it already exists\n- Insert some data into the table and read it with `pandas` (you can see the example below)\n- Commit the changes\n- Use `pandas` to compute the average salary by department\n\n```{python}\n#| echo: true\n#| eval: false\n# Create employees table first, then insert data\n'Alice', 'HR', 5000\n'Bob', 'IT', 6000\n'Charlie', 'HR', 7000\n'David', 'IT', 8000\n```\n\n- [[Appendix 04]{.button}](#sec:appendix04)\n:::\n\n# Pivot tables in SQL üìÑ {background-color=\"#2d4563\"}\n\n## Pivot tables in SQL\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- We have already seen how to pivot tables in `pandas`\n- But we can also pivot tables in SQL too\n- We can use the `CASE` function to pivot tables, which is similar to the `pivot_table()` method in `pandas`\n- Let's create another table with student scores\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nDROP TABLE IF EXISTS student_scores;\nCREATE TABLE student_scores (\n    student_name VARCHAR(50),\n    subject VARCHAR(50),\n    score INTEGER,\n    term VARCHAR(10)\n);\n\nINSERT INTO student_scores (student_name, subject, score, term)\nVALUES \n    ('Alice', 'Maths', 90, 'Q1'),\n    ('Alice', 'Maths', 80, 'Q2'),\n    ('Alice', 'Science', 80, 'Q1'),\n    ('Alice', 'Science', 75, 'Q2'),\n    ('Bob', 'Maths', 80, 'Q1'),\n    ('Bob', 'Maths', 100, 'Q2'),\n    ('Bob', 'Science', 80, 'Q1'),\n    ('Bob', 'Science', 70, 'Q2'),\n    ('Charles', 'Maths', 70, 'Q1'),\n    ('Charles', 'Maths', 75, 'Q2'),\n    ('Charles', 'Science', 90, 'Q1'),\n    ('Charles', 'Science', 85, 'Q2')\n'''))\n\nconnection.commit()\n\nconnection.execute(text('SELECT * FROM student_scores')).fetchall()\n```\n:::\n\n## Pivot tables in SQL\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- Now let's pivot the table using the `CASE` function\n- We will focus on the students' scores in Math and Science\n- Let's calculate their average scores for each subject\n\n```{python}\n#| echo: true\n#| eval: true\ndf2 = pd.read_sql('''\nSELECT \n    student_name,\n    AVG(CASE WHEN subject = 'Maths' THEN score END) as Maths,\n    AVG(CASE WHEN subject = 'Science' THEN score END) as Science,\n    AVG(score) as total\nFROM student_scores\nGROUP BY student_name\nORDER BY total DESC;\n''', connection)\n\ndf2\n```\n:::\n\n## Pivot tables in SQL\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n- PostgreSQL also has a `crosstab` function that can be used to pivot tables\n- It is a bit more complex than the `CASE` function, but it works fine\n- The syntax is `crosstab(text, text)` and it requires the `tablefunc` extension\n- We can install the extension with the command below\n\n```{python}\n#| echo: true\n#} eval: true\nconnection.execute(text('CREATE EXTENSION IF NOT EXISTS tablefunc;'))\nconnection.commit()\n\ndf3 = pd.read_sql('''\nDROP TABLE IF EXISTS ct;\nSELECT student_name, Maths, Science, (Maths + Science)/2 as Total\nFROM crosstab(\n    'SELECT student_name, subject, AVG(score)\n     FROM student_scores\n     GROUP BY student_name, subject\n     ORDER BY student_name, subject',\n    'SELECT DISTINCT subject FROM student_scores ORDER BY subject'\n) AS ct (\n    student_name VARCHAR, Maths NUMERIC, Science NUMERIC\n);\n''', connection)\n\ndf3\n```\n:::\n\n## Pivot tables in SQL\n\n:::{style=\"margin-top: 50px; font-size: 20px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- Let's break the code down \n- We first dropped the table `ct` if it already exists, just to avoid conflicts\n  - `DROP TABLE IF EXISTS ct;`\n- We then used the `crosstab` function to pivot the table\n  - `SELECT student_name, subject, AVG(score) FROM student_scores GROUP BY student_name, subject ORDER BY student_name, subject`\n  - `SELECT DISTINCT subject FROM student_scores ORDER BY subject`\n- We calculated the total score as the average of the scores in Maths and Science\n:::\n\n:::{.column width=\"50%\"}\n- The `crosstab` function requires two arguments\n  - The first argument is the query to retrieve the data\n  - The second argument is the query to retrieve the column names\n- We then used the `AS` keyword to rename the columns and assigned the result to a new table called `ct`\n  - `AS ct (student_name VARCHAR, Maths NUMERIC, Science NUMERIC)`\n- And that's it! ü§ì\n:::\n:::\n:::\n\n# Conclusion üìö {background-color=\"#2d4563\"}\n\n## Conclusion\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n:::{.columns}\n:::{.column width=\"50%\"}\n- SQL is cool, SQL + Python is even cooler! üòé\n- We can use `psycopg2` and `sqlalchemy` to connect to a PostgreSQL database\n- We can execute SQL commands with `execute()` and `fetchall()`\n- Functions like `IN`, `BETWEEN`, `LIKE`, `CASE`, and window functions are very useful\n- There are also many string functions that can be used to manipulate text data\n- We can fill missing values with `COALESCE` and pivot tables with the `CASE` function or the `crosstab` function\n- And we can use `pandas` to read data from SQL queries and manipulate it\n:::\n\n:::{.column width=\"50%\"}\n:::{style=\"text-align: center;\"}\n[![](figures/pandasql5.jpg){width=\"100%\"}](https://www.sqlalchemy.org/){data-modal-type=\"iframe\"}\n\nSource: [Susan Ibach](https://susanibach.wordpress.com/2020/01/07/pandas-for-sql-lovers-select-from-table/)\n:::\n:::\n:::\n:::\n\n# And that's all for today! üöÄ {background-color=\"#2d4563\"}\n\n# Have a great day! üòä {background-color=\"#2d4563\"}\n\n## Appendix 01 {#sec:appendix01}\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- Find all drivers whose names start with 'M'\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE driver_name LIKE 'M%';\n''')).fetchall()\n```\n\n- Find drivers whose nationality contains exactly 7 characters\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE nationality LIKE '_______';\n''')).fetchall()\n```\n\n- Or we can use the `LENGTH` function\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE LENGTH(nationality) = 7;\n''')).fetchall()\n```\n\n[[Back to exercise]{.button}](#sec:exercise01)\n:::\n\n## Appendix 01\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- List drivers whose names start with either 'L' or 'M'\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE driver_name LIKE 'L%' OR driver_name LIKE 'M%';\n''')).fetchall()\n```\n\n- Find drivers who have won between 10 and 50 races\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT * FROM drivers WHERE victories BETWEEN 1 AND 10;\n''')).fetchall()\n```\n\n[[Back to exercise]{.button}](#sec:exercise01)\n:::\n\n## Appendix 02 {#sec:appendix02}\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- Create a column called `rank_nationality` that ranks drivers based on the number of victories and their nationality\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, nationality, victories,\n    RANK() OVER (PARTITION BY nationality ORDER BY victories DESC) AS rank_nationality\nFROM drivers\nWHERE victories IS NOT NULL\nORDER BY rank_nationality\n''')).fetchall()\n```\n\n[[Back to exercise]{.button}](#sec:exercise02)\n:::\n\n\n## Appendix 03 {#sec:appendix03}\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- Create a column called `driver_level` that classifies drivers as 'Beginner', 'Intermediate', or 'Expert' based on the number of victories\n  - `Beginner` if victories < 10\n  - `Intermediate` if victories between 10 and 50\n  - `Expert` if victories > 50\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nSELECT driver_name, \n    CASE \n        WHEN victories < 10 THEN 'Beginner'\n        WHEN victories BETWEEN 10 AND 100 THEN 'Intermediate'\n        ELSE 'Expert'\n    END AS driver_level\nFROM drivers;\n''')).fetchall()\n```\n\n[[Back to exercise]{.button}](#sec:exercise02)\n:::\n\n## Appendix 04 {#sec:appendix04}\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- Create a new SQL table called `employees` with the following columns:\n  - `employee_id` (serial, primary key)\n  - `employee_name` (varchar(50))\n  - `department` (varchar(50))\n  - `salary` (int)\n- Commit the changes\n- Insert some data into the table and read it with `pandas` (you can see the example below)\n- Use `pandas` to compute the average salary by department\n\n```{python}\n#| echo: true\n#| eval: true\nconnection.execute(text('''\nDROP TABLE IF EXISTS employees;\nCREATE TABLE employees (\n    employee_id SERIAL PRIMARY KEY,\n    employee_name VARCHAR(50),\n    department VARCHAR(50),\n    salary INT\n);\n'''))\n\nconnection.execute(text('''\nINSERT INTO employees (employee_name, department, salary)\nVALUES \n    ('Alice', 'HR', 5000),\n    ('Bob', 'IT', 6000),\n    ('Charlie', 'HR', 7000),\n    ('David', 'IT', 8000)\n'''))\n\nconnection.commit()\n\n# Read data with pandas\npd.read_sql('SELECT * FROM employees', connection)\n\n# Compute average salary by department\npd.read_sql('SELECT department, AVG(salary) FROM employees GROUP BY department', connection)\n```\n\n[[Back to exercise]{.button}](#sec:exercise03)\n:::\n\n## Appendix 05 {#sec:appendix05}\n### Cleaning all tables\n\n:::{style=\"margin-top: 50px; font-size: 22px;\"}\n- I have encountered some issues with `psycopg2` when trying to drop tables\n- So I created a function to clean all tables in the database\n- If you have a similar issue, you can use the function below\n- Replace the default values with your database name, user, and password\n\n```{python}\n#| echo: true\n#| eval: false\nfrom sqlalchemy import create_engine, text, inspect\nimport time\n\nengine = create_engine('postgresql+psycopg2://postgres:postgres@localhost:5432/postgres', future=True)\nconnection = engine.connect()\n\ndef clean_database(engine):\n    with engine.connect() as conn:\n        try:\n            # Get inspector to check existing tables\n            inspector = inspect(engine)\n            existing_tables = inspector.get_table_names()\n            \n            if not existing_tables:\n                print(\"No tables found in database\")\n                return\n                \n            print(f\"Found {len(existing_tables)} tables: {existing_tables}\")\n            \n            # Kill other connections\n            conn.execute(text(\"\"\"\n                SELECT pg_terminate_backend(pid) \n                FROM pg_stat_activity \n                WHERE pid <> pg_backend_pid()\n                AND datname = current_database()\n            \"\"\"))\n            \n            conn.execute(text(\"ROLLBACK\"))\n            conn.execute(text(\"SET statement_timeout = '30s'\"))\n            \n            # Only drop tables that exist\n            for table in existing_tables:\n                try:\n                    conn.execute(text(f\"DROP TABLE IF EXISTS {table} CASCADE\"))\n                    print(f\"Dropped {table}\")\n                    conn.commit()\n                    time.sleep(1)\n                except Exception as e:\n                    print(f\"Error with {table}: {str(e)}\")\n                    conn.execute(text(\"ROLLBACK\"))\n                    \n        except Exception as e:\n            print(f\"Fatal error: {str(e)}\")\n            conn.execute(text(\"ROLLBACK\"))\n\n# Execute\nclean_database(engine)\n```\n\n[[Back to the lecture]{.button}](#sec:tables)\n:::\n"},"formats":{"clean-revealjs":{"identifier":{"display-name":"RevealJS","target-format":"clean-revealjs","base-format":"revealjs","extension-name":"clean"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"shortcodes":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","filters":[],"self-contained":true,"output-file":"19-sql-python.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.6.42","auto-stretch":true,"theme":["default","../../_extensions/grantmcdermott/clean/clean.scss"],"menu":{"side":"left"},"slideNumber":true,"date-format":"long","revealjs-plugins":["fontawesome","multimodal"],"title":"QTM 350 - Data Science Computing","subtitle":"Lecture 19 - SQL and Python","author":[{"name":"Danilo Freire","email":"danilo.freire@emory.edu","affiliations":"Emory University"}],"transition":"slide","transitionSpeed":"default","scrollable":true,"editor":{"render-on-save":true},"footer":"[SQL and Python](https://raw.githack.com/danilofreire/qtm350/main/lectures/lecture-19/19-sql-python.html)"}}},"projectFormats":["html"]}